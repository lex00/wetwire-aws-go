package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"time"
)

// GenerationStats tracks what was generated.
type GenerationStats struct {
	Services      int
	Resources     int
	PropertyTypes int
	FilesWritten  int
}

// generateCode generates Go files for all services.
func generateCode(services []*Service, outputDir string, dryRun bool) (*GenerationStats, error) {
	stats := &GenerationStats{
		Services: len(services),
	}

	for _, svc := range services {
		if err := generateService(svc, outputDir, dryRun, stats); err != nil {
			return stats, fmt.Errorf("generating %s: %w", svc.Name, err)
		}
	}

	return stats, nil
}

func generateService(svc *Service, outputDir string, dryRun bool, stats *GenerationStats) error {
	// Create service directory under resources/
	svcDir := filepath.Join(outputDir, "resources", svc.Name)
	if !dryRun {
		if err := os.MkdirAll(svcDir, 0755); err != nil {
			return err
		}
	}

	// Generate each resource as a separate file
	for _, res := range svc.Resources {
		code, err := generateResource(svc, res)
		if err != nil {
			return fmt.Errorf("generating %s: %w", res.Name, err)
		}

		filename := filepath.Join(svcDir, toSnakeCase(res.Name)+".go")
		if dryRun {
			fmt.Printf("Would write: %s\n", filename)
		} else {
			if err := os.WriteFile(filename, code, 0644); err != nil {
				return err
			}
			stats.FilesWritten++
		}
		stats.Resources++
	}

	// Group property types by parent resource
	typesByResource := make(map[string][]string) // resourceName -> list of property type names
	for name, propType := range svc.PropertyTypes {
		parent := propType.ParentResource
		typesByResource[parent] = append(typesByResource[parent], name)
	}

	// Generate per-resource type files (e.g., security_group_types.go)
	for resourceName, typeNames := range typesByResource {
		sort.Strings(typeNames)

		code, err := generateResourcePropertyTypes(svc, resourceName, typeNames)
		if err != nil {
			return fmt.Errorf("generating property types for %s: %w", resourceName, err)
		}

		filename := filepath.Join(svcDir, toSnakeCase(resourceName)+"_types.go")
		if dryRun {
			fmt.Printf("Would write: %s\n", filename)
		} else {
			if err := os.WriteFile(filename, code, 0644); err != nil {
				return err
			}
			stats.FilesWritten++
		}
	}
	stats.PropertyTypes += len(svc.PropertyTypes)

	// Generate types.go for shared types (Tag only, unless service has Tag resource)
	_, hasTagResource := svc.Resources["Tag"]
	if !hasTagResource {
		typesCode := generateSharedTypes(svc)
		typesFile := filepath.Join(svcDir, "types.go")
		if dryRun {
			fmt.Printf("Would write: %s\n", typesFile)
		} else {
			if err := os.WriteFile(typesFile, typesCode, 0644); err != nil {
				return err
			}
			stats.FilesWritten++
		}
	}

	// Generate doc.go for the package
	docCode := generateDoc(svc)
	docFile := filepath.Join(svcDir, "doc.go")
	if dryRun {
		fmt.Printf("Would write: %s\n", docFile)
	} else {
		if err := os.WriteFile(docFile, docCode, 0644); err != nil {
			return err
		}
		stats.FilesWritten++
	}

	// Generate enums.go if the service has enums
	if err := generateEnumsFile(svc, svcDir, dryRun, stats); err != nil {
		return fmt.Errorf("generating enums: %w", err)
	}

	return nil
}

var resourceTemplate = template.Must(template.New("resource").Parse(`// Code generated by wetwire-aws codegen. DO NOT EDIT.
// Source: CloudFormation Resource Specification
// Generated: {{ .Timestamp }}

package {{ .PackageName }}
{{ if .HasAttributes }}
import (
	wetwire "github.com/lex00/wetwire-aws-go"
)
{{ end }}
{{ if .Documentation }}
// {{ .ResourceName }} represents {{ .CFType }}.
// {{ .Documentation }}
{{ else }}
// {{ .ResourceName }} represents {{ .CFType }}.
{{ end }}
type {{ .ResourceName }} struct {
{{ if .HasAttributes }}	// Attributes for Fn::GetAtt
{{ range .Attributes }}	{{ .GoName }} wetwire.AttrRef ` + "`json:\"-\"`" + `
{{ end }}{{ end }}
	// Properties
{{ range .Properties }}{{ if .Documentation }}	// {{ .Documentation }}
{{ end }}	{{ .Name }} {{ .GoType }} ` + "`json:\"{{ .JSONName }},omitempty\"`" + `
{{ end }}}

// ResourceType returns the CloudFormation resource type.
func (r {{ .ResourceName }}) ResourceType() string {
	return "{{ .CFType }}"
}
`))

type resourceTemplateData struct {
	PackageName   string
	ResourceName  string
	CFType        string
	Documentation string
	Timestamp     string
	Properties    []propertyData
	Attributes    []attributeData
	HasAttributes bool // true if there are any attributes (for conditional import)
}

type propertyData struct {
	Name          string
	GoType        string
	JSONName      string
	Documentation string
}

type attributeData struct {
	Name   string
	GoName string // Sanitized Go identifier
	CFName string // Original CloudFormation attribute name
}

func generateResource(svc *Service, res ParsedResource) ([]byte, error) {
	// Build map of property type names to qualified names for this service.
	// Property types are named as ParentResource_PropertyType.
	// When multiple property types share the same simple name, prefer the one
	// from the same parent resource as the current resource.
	// The map key in svc.PropertyTypes is already qualified (e.g., "Bucket_PublicAccessBlockConfiguration"),
	// and pt.Name is the short name (e.g., "PublicAccessBlockConfiguration").
	// Use sorted iteration for deterministic results.
	sortedTypeKeys := make([]string, 0, len(svc.PropertyTypes))
	for k := range svc.PropertyTypes {
		sortedTypeKeys = append(sortedTypeKeys, k)
	}
	sort.Strings(sortedTypeKeys)

	propTypeNames := make(map[string]string)
	for _, qualifiedKey := range sortedTypeKeys {
		pt := svc.PropertyTypes[qualifiedKey]
		// qualifiedKey is already "ParentResource_PropertyType"
		// pt.Name is just "PropertyType"
		// Prefer property types from the same parent resource
		if pt.ParentResource == res.Name {
			propTypeNames[pt.Name] = qualifiedKey
		} else if _, exists := propTypeNames[pt.Name]; !exists {
			propTypeNames[pt.Name] = qualifiedKey
		}
	}

	// Prepare properties
	var props []propertyData
	propNames := make([]string, 0, len(res.Properties))
	for name := range res.Properties {
		propNames = append(propNames, name)
	}
	sort.Strings(propNames)

	for _, name := range propNames {
		prop := res.Properties[name]
		goType := resolveTypeReferences(prop.GoType, propTypeNames, prop.IsPointer)

		// Special case: Tags uses []any to allow intrinsics.Tag from dot import
		if goType == "[]Tag" {
			goType = "[]any"
		}

		// Clean up documentation
		doc := cleanDoc(prop.Documentation)

		// Rename properties that conflict with struct methods or Go keywords
		goName := name
		if name == "ResourceType" {
			goName = "ResourceTypeProp"
		} else if isGoKeyword(name) {
			goName = name + "_"
		}

		props = append(props, propertyData{
			Name:          goName,
			GoType:        goType,
			JSONName:      name,
			Documentation: doc,
		})
	}

	// Build set of property names to avoid attribute conflicts
	propNameSet := make(map[string]bool)
	for _, p := range props {
		propNameSet[p.Name] = true
	}

	// Prepare attributes (sanitized and non-conflicting)
	var attrs []attributeData
	attrNames := make([]string, 0, len(res.Attributes))
	for name := range res.Attributes {
		attrNames = append(attrNames, name)
	}
	sort.Strings(attrNames)

	for _, name := range attrNames {
		// Sanitize: replace dots with underscores for valid Go identifiers
		goName := strings.ReplaceAll(name, ".", "_")
		// Skip attributes that conflict with property names
		if propNameSet[goName] {
			continue
		}
		// Rename attributes that conflict with struct methods
		if goName == "ResourceType" {
			goName = "ResourceTypeAttr"
		}
		attrs = append(attrs, attributeData{
			Name:   goName,
			GoName: goName,
			CFName: name,
		})
	}

	// Clean up documentation
	doc := cleanDoc(res.Documentation)

	data := resourceTemplateData{
		PackageName:   svc.Name,
		ResourceName:  res.Name,
		CFType:        res.CFType,
		Documentation: doc,
		Timestamp:     time.Now().Format(time.RFC3339),
		Properties:    props,
		Attributes:    attrs,
		HasAttributes: len(attrs) > 0,
	}

	var buf bytes.Buffer
	if err := resourceTemplate.Execute(&buf, data); err != nil {
		return nil, err
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted if formatting fails
		return buf.Bytes(), nil
	}

	return formatted, nil
}

func generateDoc(svc *Service) []byte {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by wetwire-aws codegen. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("// Package %s provides CloudFormation resources for AWS %s.\n",
		svc.Name, strings.ToUpper(svc.Name)))
	buf.WriteString(fmt.Sprintf("package %s\n", svc.Name))
	return buf.Bytes()
}

// isGoKeyword checks if a name is a Go keyword.
func isGoKeyword(s string) bool {
	keywords := map[string]bool{
		"break": true, "case": true, "chan": true, "const": true, "continue": true,
		"default": true, "defer": true, "else": true, "fallthrough": true, "for": true,
		"func": true, "go": true, "goto": true, "if": true, "import": true,
		"interface": true, "map": true, "package": true, "range": true, "return": true,
		"select": true, "struct": true, "switch": true, "type": true, "var": true,
	}
	return keywords[strings.ToLower(s)]
}

// toSnakeCase converts PascalCase to snake_case.
func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}

// resolveTypeReferences resolves property type names to their qualified names.
// Handles simple types, slices, maps, and pointers.
func resolveTypeReferences(goType string, qualifiedNames map[string]string, isPointer bool) string {
	// Handle slice types like []SomeType
	if strings.HasPrefix(goType, "[]") {
		baseType := strings.TrimPrefix(goType, "[]")
		if qn, ok := qualifiedNames[baseType]; ok {
			return "[]" + qn
		}
		return goType
	}

	// Handle map types like map[string]SomeType
	if strings.HasPrefix(goType, "map[string]") {
		baseType := strings.TrimPrefix(goType, "map[string]")
		if qn, ok := qualifiedNames[baseType]; ok {
			return "map[string]" + qn
		}
		return goType
	}

	// Handle simple types
	if qn, ok := qualifiedNames[goType]; ok {
		goType = qn
	}

	// Use `any` for pointer/optional fields to allow intrinsics like If{}
	// CloudFormation allows intrinsics for any property, but *Type is too restrictive.
	// Using `any` preserves type safety for direct usage while allowing If{}, Sub{}, etc.
	if isPointer {
		return "any"
	}

	return goType
}

// cleanDoc cleans up CloudFormation documentation for Go comments.
func cleanDoc(doc string) string {
	if doc == "" {
		return ""
	}
	// Remove URLs and HTML
	doc = strings.ReplaceAll(doc, "\n", " ")
	if idx := strings.Index(doc, "http"); idx != -1 {
		doc = doc[:idx]
	}
	doc = strings.TrimSpace(doc)
	if len(doc) > 200 {
		doc = doc[:200] + "..."
	}
	return doc
}
