package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"time"
	"unicode"

	"github.com/lex00/cloudformation-schema-go/enums"
)

// GenerationStats tracks what was generated.
type GenerationStats struct {
	Services      int
	Resources     int
	PropertyTypes int
	FilesWritten  int
}

// generateCode generates Go files for all services.
func generateCode(services []*Service, outputDir string, dryRun bool) (*GenerationStats, error) {
	stats := &GenerationStats{
		Services: len(services),
	}

	for _, svc := range services {
		if err := generateService(svc, outputDir, dryRun, stats); err != nil {
			return stats, fmt.Errorf("generating %s: %w", svc.Name, err)
		}
	}

	return stats, nil
}

func generateService(svc *Service, outputDir string, dryRun bool, stats *GenerationStats) error {
	// Create service directory under resources/
	svcDir := filepath.Join(outputDir, "resources", svc.Name)
	if !dryRun {
		if err := os.MkdirAll(svcDir, 0755); err != nil {
			return err
		}
	}

	// Generate each resource as a separate file
	for _, res := range svc.Resources {
		code, err := generateResource(svc, res)
		if err != nil {
			return fmt.Errorf("generating %s: %w", res.Name, err)
		}

		filename := filepath.Join(svcDir, toSnakeCase(res.Name)+".go")
		if dryRun {
			fmt.Printf("Would write: %s\n", filename)
		} else {
			if err := os.WriteFile(filename, code, 0644); err != nil {
				return err
			}
			stats.FilesWritten++
		}
		stats.Resources++
	}

	// Group property types by parent resource
	typesByResource := make(map[string][]string) // resourceName -> list of property type names
	for name, propType := range svc.PropertyTypes {
		parent := propType.ParentResource
		typesByResource[parent] = append(typesByResource[parent], name)
	}

	// Generate per-resource type files (e.g., security_group_types.go)
	for resourceName, typeNames := range typesByResource {
		sort.Strings(typeNames)

		code, err := generateResourcePropertyTypes(svc, resourceName, typeNames)
		if err != nil {
			return fmt.Errorf("generating property types for %s: %w", resourceName, err)
		}

		filename := filepath.Join(svcDir, toSnakeCase(resourceName)+"_types.go")
		if dryRun {
			fmt.Printf("Would write: %s\n", filename)
		} else {
			if err := os.WriteFile(filename, code, 0644); err != nil {
				return err
			}
			stats.FilesWritten++
		}
	}
	stats.PropertyTypes += len(svc.PropertyTypes)

	// Generate types.go for shared types (Tag only, unless service has Tag resource)
	_, hasTagResource := svc.Resources["Tag"]
	if !hasTagResource {
		typesCode := generateSharedTypes(svc)
		typesFile := filepath.Join(svcDir, "types.go")
		if dryRun {
			fmt.Printf("Would write: %s\n", typesFile)
		} else {
			if err := os.WriteFile(typesFile, typesCode, 0644); err != nil {
				return err
			}
			stats.FilesWritten++
		}
	}

	// Generate doc.go for the package
	docCode := generateDoc(svc)
	docFile := filepath.Join(svcDir, "doc.go")
	if dryRun {
		fmt.Printf("Would write: %s\n", docFile)
	} else {
		if err := os.WriteFile(docFile, docCode, 0644); err != nil {
			return err
		}
		stats.FilesWritten++
	}

	// Generate enums.go if the service has enums
	if err := generateEnumsFile(svc, svcDir, dryRun, stats); err != nil {
		return fmt.Errorf("generating enums: %w", err)
	}

	return nil
}

var resourceTemplate = template.Must(template.New("resource").Parse(`// Code generated by wetwire-aws codegen. DO NOT EDIT.
// Source: CloudFormation Resource Specification
// Generated: {{ .Timestamp }}

package {{ .PackageName }}
{{ if .HasAttributes }}
import (
	wetwire "github.com/lex00/wetwire-aws-go"
)
{{ end }}
{{ if .Documentation }}
// {{ .ResourceName }} represents {{ .CFType }}.
// {{ .Documentation }}
{{ else }}
// {{ .ResourceName }} represents {{ .CFType }}.
{{ end }}
type {{ .ResourceName }} struct {
{{ if .HasAttributes }}	// Attributes for Fn::GetAtt
{{ range .Attributes }}	{{ .GoName }} wetwire.AttrRef ` + "`json:\"-\"`" + `
{{ end }}{{ end }}
	// Properties
{{ range .Properties }}{{ if .Documentation }}	// {{ .Documentation }}
{{ end }}	{{ .Name }} {{ .GoType }} ` + "`json:\"{{ .JSONName }},omitempty\"`" + `
{{ end }}}

// ResourceType returns the CloudFormation resource type.
func (r {{ .ResourceName }}) ResourceType() string {
	return "{{ .CFType }}"
}
`))

type resourceTemplateData struct {
	PackageName   string
	ResourceName  string
	CFType        string
	Documentation string
	Timestamp     string
	Properties    []propertyData
	Attributes    []attributeData
	HasAttributes bool // true if there are any attributes (for conditional import)
}

type propertyData struct {
	Name          string
	GoType        string
	JSONName      string
	Documentation string
}

type attributeData struct {
	Name   string
	GoName string // Sanitized Go identifier
	CFName string // Original CloudFormation attribute name
}

func generateResource(svc *Service, res ParsedResource) ([]byte, error) {
	// Build map of property type names to qualified names for this service.
	// Property types are named as ParentResource_PropertyType.
	// When multiple property types share the same simple name, prefer the one
	// from the same parent resource as the current resource.
	// The map key in svc.PropertyTypes is already qualified (e.g., "Bucket_PublicAccessBlockConfiguration"),
	// and pt.Name is the short name (e.g., "PublicAccessBlockConfiguration").
	// Use sorted iteration for deterministic results.
	sortedTypeKeys := make([]string, 0, len(svc.PropertyTypes))
	for k := range svc.PropertyTypes {
		sortedTypeKeys = append(sortedTypeKeys, k)
	}
	sort.Strings(sortedTypeKeys)

	propTypeNames := make(map[string]string)
	for _, qualifiedKey := range sortedTypeKeys {
		pt := svc.PropertyTypes[qualifiedKey]
		// qualifiedKey is already "ParentResource_PropertyType"
		// pt.Name is just "PropertyType"
		// Prefer property types from the same parent resource
		if pt.ParentResource == res.Name {
			propTypeNames[pt.Name] = qualifiedKey
		} else if _, exists := propTypeNames[pt.Name]; !exists {
			propTypeNames[pt.Name] = qualifiedKey
		}
	}

	// Prepare properties
	var props []propertyData
	propNames := make([]string, 0, len(res.Properties))
	for name := range res.Properties {
		propNames = append(propNames, name)
	}
	sort.Strings(propNames)

	for _, name := range propNames {
		prop := res.Properties[name]
		goType := resolveTypeReferences(prop.GoType, propTypeNames, prop.IsPointer)

		// Special case: Tags uses []any to allow intrinsics.Tag from dot import
		if goType == "[]Tag" {
			goType = "[]any"
		}

		// Clean up documentation
		doc := cleanDoc(prop.Documentation)

		// Rename properties that conflict with struct methods or Go keywords
		goName := name
		if name == "ResourceType" {
			goName = "ResourceTypeProp"
		} else if isGoKeyword(name) {
			goName = name + "_"
		}

		props = append(props, propertyData{
			Name:          goName,
			GoType:        goType,
			JSONName:      name,
			Documentation: doc,
		})
	}

	// Build set of property names to avoid attribute conflicts
	propNameSet := make(map[string]bool)
	for _, p := range props {
		propNameSet[p.Name] = true
	}

	// Prepare attributes (sanitized and non-conflicting)
	var attrs []attributeData
	attrNames := make([]string, 0, len(res.Attributes))
	for name := range res.Attributes {
		attrNames = append(attrNames, name)
	}
	sort.Strings(attrNames)

	for _, name := range attrNames {
		// Sanitize: replace dots with underscores for valid Go identifiers
		goName := strings.ReplaceAll(name, ".", "_")
		// Skip attributes that conflict with property names
		if propNameSet[goName] {
			continue
		}
		// Rename attributes that conflict with struct methods
		if goName == "ResourceType" {
			goName = "ResourceTypeAttr"
		}
		attrs = append(attrs, attributeData{
			Name:   goName,
			GoName: goName,
			CFName: name,
		})
	}

	// Clean up documentation
	doc := cleanDoc(res.Documentation)

	data := resourceTemplateData{
		PackageName:   svc.Name,
		ResourceName:  res.Name,
		CFType:        res.CFType,
		Documentation: doc,
		Timestamp:     time.Now().Format(time.RFC3339),
		Properties:    props,
		Attributes:    attrs,
		HasAttributes: len(attrs) > 0,
	}

	var buf bytes.Buffer
	if err := resourceTemplate.Execute(&buf, data); err != nil {
		return nil, err
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted if formatting fails
		return buf.Bytes(), nil
	}

	return formatted, nil
}

func generateDoc(svc *Service) []byte {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by wetwire-aws codegen. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("// Package %s provides CloudFormation resources for AWS %s.\n",
		svc.Name, strings.ToUpper(svc.Name)))
	buf.WriteString(fmt.Sprintf("package %s\n", svc.Name))
	return buf.Bytes()
}

// isGoKeyword checks if a name is a Go keyword.
func isGoKeyword(s string) bool {
	keywords := map[string]bool{
		"break": true, "case": true, "chan": true, "const": true, "continue": true,
		"default": true, "defer": true, "else": true, "fallthrough": true, "for": true,
		"func": true, "go": true, "goto": true, "if": true, "import": true,
		"interface": true, "map": true, "package": true, "range": true, "return": true,
		"select": true, "struct": true, "switch": true, "type": true, "var": true,
	}
	return keywords[strings.ToLower(s)]
}

// toSnakeCase converts PascalCase to snake_case.
func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}

// resolveTypeReferences resolves property type names to their qualified names.
// Handles simple types, slices, maps, and pointers.
func resolveTypeReferences(goType string, qualifiedNames map[string]string, isPointer bool) string {
	// Handle slice types like []SomeType
	if strings.HasPrefix(goType, "[]") {
		baseType := strings.TrimPrefix(goType, "[]")
		if qn, ok := qualifiedNames[baseType]; ok {
			return "[]" + qn
		}
		return goType
	}

	// Handle map types like map[string]SomeType
	if strings.HasPrefix(goType, "map[string]") {
		baseType := strings.TrimPrefix(goType, "map[string]")
		if qn, ok := qualifiedNames[baseType]; ok {
			return "map[string]" + qn
		}
		return goType
	}

	// Handle simple types
	if qn, ok := qualifiedNames[goType]; ok {
		goType = qn
	}

	// Use `any` for pointer/optional fields to allow intrinsics like If{}
	// CloudFormation allows intrinsics for any property, but *Type is too restrictive.
	// Using `any` preserves type safety for direct usage while allowing If{}, Sub{}, etc.
	if isPointer {
		return "any"
	}

	return goType
}

// cleanDoc cleans up CloudFormation documentation for Go comments.
func cleanDoc(doc string) string {
	if doc == "" {
		return ""
	}
	// Remove URLs and HTML
	doc = strings.ReplaceAll(doc, "\n", " ")
	if idx := strings.Index(doc, "http"); idx != -1 {
		doc = doc[:idx]
	}
	doc = strings.TrimSpace(doc)
	if len(doc) > 200 {
		doc = doc[:200] + "..."
	}
	return doc
}

var propertyTypesTemplate = template.Must(template.New("types").Parse(`// Code generated by wetwire-aws codegen. DO NOT EDIT.
// Source: CloudFormation Resource Specification
// Generated: {{ .Timestamp }}

package {{ .PackageName }}
{{ if not .SkipTag }}
// Tag represents a CloudFormation tag.
// This is a shared type used across all services.
type Tag struct {
	Key   string ` + "`json:\"Key\"`" + `
	Value any    ` + "`json:\"Value\"`" + `
}
{{ end }}

{{ range .Types }}
{{ if .Documentation }}// {{ .Name }} represents {{ .CFType }}.
// {{ .Documentation }}
{{ else }}// {{ .Name }} represents {{ .CFType }}.
{{ end }}type {{ .Name }} struct {
{{ range .Properties }}{{ if .Documentation }}	// {{ .Documentation }}
{{ end }}	{{ .Name }} {{ .GoType }} ` + "`json:\"{{ .JSONName }},omitempty\"`" + `
{{ end }}}
{{ end }}
`))

type typesTemplateData struct {
	PackageName string
	Timestamp   string
	Types       []typeData
	SkipTag     bool // True if the service has a Tag resource (to avoid conflict)
}

type typeData struct {
	Name          string
	CFType        string
	Documentation string
	Properties    []propertyData
}

// generateSharedTypes generates types.go with only shared types (Tag).
func generateSharedTypes(svc *Service) []byte {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by wetwire-aws codegen. DO NOT EDIT.\n")
	buf.WriteString("// Source: CloudFormation Resource Specification\n")
	buf.WriteString(fmt.Sprintf("// Generated: %s\n\n", time.Now().Format(time.RFC3339)))
	buf.WriteString(fmt.Sprintf("package %s\n\n", svc.Name))
	buf.WriteString("// Tag represents a CloudFormation tag.\n")
	buf.WriteString("// This is a shared type used across all services.\n")
	buf.WriteString("type Tag struct {\n")
	buf.WriteString("\tKey   string `json:\"Key\"`\n")
	buf.WriteString("\tValue any    `json:\"Value\"`\n")
	buf.WriteString("}\n")
	return buf.Bytes()
}

// generateResourcePropertyTypes generates a {resource}_types.go file for property types of a single resource.
func generateResourcePropertyTypes(svc *Service, resourceName string, typeNames []string) ([]byte, error) {
	// Build qualified names map for type reference resolution.
	// The map key in svc.PropertyTypes is already qualified (e.g., "Bucket_PublicAccessBlockConfiguration").
	// Sort keys for deterministic ordering (alphabetically first wins for short names).
	qualifiedNames := make(map[string]string)
	sortedTypeKeys := make([]string, 0, len(svc.PropertyTypes))
	for k := range svc.PropertyTypes {
		sortedTypeKeys = append(sortedTypeKeys, k)
	}
	sort.Strings(sortedTypeKeys)
	for _, qualifiedKey := range sortedTypeKeys {
		propType := svc.PropertyTypes[qualifiedKey]
		// Map short name to qualified key (first alphabetically wins)
		if _, exists := qualifiedNames[propType.Name]; !exists {
			qualifiedNames[propType.Name] = qualifiedKey
		}
		// Also map qualified key to itself for explicit lookups
		qualifiedNames[qualifiedKey] = qualifiedKey
	}

	var types []typeData
	for _, qualifiedKey := range typeNames {
		propType := svc.PropertyTypes[qualifiedKey]
		// qualifiedKey is already "ResourceName_PropertyType"
		qualifiedName := qualifiedKey

		// Sort properties
		propNames := make([]string, 0, len(propType.Properties))
		for pn := range propType.Properties {
			propNames = append(propNames, pn)
		}
		sort.Strings(propNames)

		var props []propertyData
		for _, pn := range propNames {
			prop := propType.Properties[pn]
			goType := resolveTypeReferences(prop.GoType, qualifiedNames, prop.IsPointer)

			goName := pn
			if isGoKeyword(pn) {
				goName = pn + "_"
			}

			props = append(props, propertyData{
				Name:          goName,
				GoType:        goType,
				JSONName:      pn,
				Documentation: cleanDoc(prop.Documentation),
			})
		}

		types = append(types, typeData{
			Name:          qualifiedName,
			CFType:        propType.CFType,
			Documentation: cleanDoc(propType.Documentation),
			Properties:    props,
		})
	}

	data := typesTemplateData{
		PackageName: svc.Name,
		Timestamp:   time.Now().Format(time.RFC3339),
		Types:       types,
		SkipTag:     true, // Always skip Tag in per-resource files (it's in types.go)
	}

	var buf bytes.Buffer
	if err := propertyTypesTemplate.Execute(&buf, data); err != nil {
		return nil, err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.Bytes(), nil
	}

	return formatted, nil
}

// generateRegistry creates resources/registry.go with all property type names and mappings.
// This allows the importer to check if a type exists and look up the correct type for a property.
func generateRegistry(services []*Service, outputDir string, dryRun bool) error {
	// PropertyTypes: map of all property type names for existence check.
	// The map key in svc.PropertyTypes is already qualified (e.g., "Bucket_PublicAccessBlockConfiguration").
	var typeEntries []string
	for _, svc := range services {
		for qualifiedKey := range svc.PropertyTypes {
			// Format: "service.Resource_PropertyType"
			fullName := fmt.Sprintf("%s.%s", svc.Name, qualifiedKey)
			typeEntries = append(typeEntries, fullName)
		}
	}
	sort.Strings(typeEntries)

	// PropertyTypeMap: maps property paths to their actual type names
	// Format: "service.Resource.PropertyName" -> "Resource_ActualTypeName"
	// Format: "service.Resource_Type.PropertyName" -> "Resource_ActualTypeName"
	propMap := make(map[string]string)

	for _, svc := range services {
		// Build sorted list of property type keys for deterministic ordering.
		sortedTypeKeys := make([]string, 0, len(svc.PropertyTypes))
		for k := range svc.PropertyTypes {
			sortedTypeKeys = append(sortedTypeKeys, k)
		}
		sort.Strings(sortedTypeKeys)

		// Build qualifiedNames map with deterministic ordering (alphabetically first wins).
		// This matches the logic in generateResourcePropertyTypes.
		qualifiedNames := make(map[string]string)
		for _, qualifiedKey := range sortedTypeKeys {
			propType := svc.PropertyTypes[qualifiedKey]
			if _, exists := qualifiedNames[propType.Name]; !exists {
				qualifiedNames[propType.Name] = qualifiedKey
			}
			qualifiedNames[qualifiedKey] = qualifiedKey
		}

		// resolveTypeName resolves a short type name to its qualified form.
		resolveTypeName := func(shortName string) string {
			if qn, ok := qualifiedNames[shortName]; ok {
				return qn
			}
			return shortName
		}

		// Map resource properties to their types.
		// For resources, we use parent preference (matching generateResource logic).
		for resName, res := range svc.Resources {
			// Build propTypeNames with parent preference for this resource
			// (matching the logic in generateResource at lines 180-196)
			propTypeNames := make(map[string]string)
			for _, qualifiedKey := range sortedTypeKeys {
				pt := svc.PropertyTypes[qualifiedKey]
				// Prefer property types from the same parent resource
				if pt.ParentResource == resName {
					propTypeNames[pt.Name] = qualifiedKey
				} else if _, exists := propTypeNames[pt.Name]; !exists {
					propTypeNames[pt.Name] = qualifiedKey
				}
			}

			resolveForResource := func(shortName string) string {
				if qn, ok := propTypeNames[shortName]; ok {
					return qn
				}
				return shortName
			}

			for propName, prop := range res.Properties {
				// Skip primitives and any
				if prop.GoType == "any" || prop.GoType == "" {
					continue
				}

				var typeName string
				if prop.IsList && prop.ItemType != "" && !isPrimitive(prop.ItemType) {
					// List of property types: []SomeType
					typeName = resolveForResource(prop.ItemType)
				} else if prop.IsMap && prop.ItemType != "" && !isPrimitive(prop.ItemType) {
					// Map of property types: map[string]SomeType
					typeName = resolveForResource(prop.ItemType)
				} else if !prop.IsList && !prop.IsMap && !isPrimitive(prop.GoType) {
					// Direct property type reference
					typeName = resolveForResource(prop.GoType)
				}

				if typeName != "" {
					// Check if this type exists
					fullTypeName := svc.Name + "." + typeName
					exists := false
					for _, e := range typeEntries {
						if e == fullTypeName {
							exists = true
							break
						}
					}
					if exists {
						key := fmt.Sprintf("%s.%s.%s", svc.Name, resName, propName)
						propMap[key] = typeName
					}
				}
			}
		}

		// Map property type properties to their types.
		// The map key is already qualified (e.g., "Bucket_PublicAccessBlockConfiguration").
		for qualifiedKey, pt := range svc.PropertyTypes {
			// qualifiedKey is already the qualified type name
			parentTypeName := qualifiedKey
			for propName, prop := range pt.Properties {
				// Skip primitives and any (but not []any - list properties)
				if prop.GoType == "any" || prop.GoType == "" {
					continue
				}

				var typeName string
				if prop.IsList && prop.ItemType != "" && !isPrimitive(prop.ItemType) {
					// List of property types
					typeName = resolveTypeName(prop.ItemType)
				} else if prop.IsMap && prop.ItemType != "" && !isPrimitive(prop.ItemType) {
					// Map of property types
					typeName = resolveTypeName(prop.ItemType)
				} else if !prop.IsList && !prop.IsMap && !isPrimitive(prop.GoType) {
					// Direct property type reference
					typeName = resolveTypeName(prop.GoType)
				}

				if typeName != "" {
					// Check if this type exists
					fullTypeName := svc.Name + "." + typeName
					exists := false
					for _, e := range typeEntries {
						if e == fullTypeName {
							exists = true
							break
						}
					}
					if exists {
						key := fmt.Sprintf("%s.%s.%s", svc.Name, parentTypeName, propName)
						propMap[key] = typeName
					}
				}
			}
		}
	}

	// Sort property map keys
	propMapKeys := make([]string, 0, len(propMap))
	for k := range propMap {
		propMapKeys = append(propMapKeys, k)
	}
	sort.Strings(propMapKeys)

	// PointerFields: tracks which fields expect pointer types
	// Format: "service.ParentType.PropertyName" -> true if pointer
	pointerFields := make(map[string]bool)

	for _, svc := range services {
		// Check resource properties
		for resName, res := range svc.Resources {
			for propName, prop := range res.Properties {
				if prop.IsPointer {
					key := fmt.Sprintf("%s.%s.%s", svc.Name, resName, propName)
					pointerFields[key] = true
				}
			}
		}

		// Check property type properties
		for qualifiedKey, pt := range svc.PropertyTypes {
			for propName, prop := range pt.Properties {
				if prop.IsPointer {
					key := fmt.Sprintf("%s.%s.%s", svc.Name, qualifiedKey, propName)
					pointerFields[key] = true
				}
			}
		}
	}

	// Sort pointer fields keys
	pointerFieldKeys := make([]string, 0, len(pointerFields))
	for k := range pointerFields {
		pointerFieldKeys = append(pointerFieldKeys, k)
	}
	sort.Strings(pointerFieldKeys)

	// Generate the registry file content
	var buf bytes.Buffer
	buf.WriteString("// Code generated by wetwire-aws codegen. DO NOT EDIT.\n\n")
	buf.WriteString("package resources\n\n")

	buf.WriteString("// PropertyTypes lists all generated property type names.\n")
	buf.WriteString("// Used by the importer to check if a type exists.\n")
	buf.WriteString("var PropertyTypes = map[string]bool{\n")
	for _, entry := range typeEntries {
		buf.WriteString(fmt.Sprintf("\t%q: true,\n", entry))
	}
	buf.WriteString("}\n\n")

	buf.WriteString("// PropertyTypeMap maps property paths to their actual type names.\n")
	buf.WriteString("// Format: \"service.ParentType.PropertyName\" -> \"ParentResource_ActualTypeName\"\n")
	buf.WriteString("// Used by the importer to look up the correct type for a property.\n")
	buf.WriteString("var PropertyTypeMap = map[string]string{\n")
	for _, key := range propMapKeys {
		buf.WriteString(fmt.Sprintf("\t%q: %q,\n", key, propMap[key]))
	}
	buf.WriteString("}\n\n")

	buf.WriteString("// PointerFields tracks which property fields expect pointer types.\n")
	buf.WriteString("// Format: \"service.ParentType.PropertyName\" -> true if pointer\n")
	buf.WriteString("// Used by the importer to determine if a block should be a pointer.\n")
	buf.WriteString("var PointerFields = map[string]bool{\n")
	for _, key := range pointerFieldKeys {
		buf.WriteString(fmt.Sprintf("\t%q: true,\n", key))
	}
	buf.WriteString("}\n")

	// Write the file
	resourcesDir := filepath.Join(outputDir, "resources")
	registryFile := filepath.Join(resourcesDir, "registry.go")

	if dryRun {
		fmt.Printf("Would write: %s (%d property types, %d mappings)\n", registryFile, len(typeEntries), len(propMap))
		return nil
	}

	// Ensure resources directory exists
	if err := os.MkdirAll(resourcesDir, 0755); err != nil {
		return fmt.Errorf("creating resources directory: %w", err)
	}

	if err := os.WriteFile(registryFile, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("writing registry file: %w", err)
	}

	fmt.Printf("Generated registry with %d property types, %d mappings: %s\n", len(typeEntries), len(propMap), registryFile)
	return nil
}

// isPrimitive checks if a type is a Go primitive (not a property type reference).
func isPrimitive(t string) bool {
	primitives := map[string]bool{
		"string": true, "int": true, "int64": true, "float64": true,
		"bool": true, "any": true, "": true,
	}
	return primitives[t]
}

// generateEnumsFile generates enums.go with typed enum constants for a service.
func generateEnumsFile(svc *Service, svcDir string, dryRun bool, stats *GenerationStats) error {
	enumNames := enums.GetEnumNames(svc.Name)
	if len(enumNames) == 0 {
		return nil
	}

	var buf bytes.Buffer
	buf.WriteString("// Code generated by wetwire-aws codegen. DO NOT EDIT.\n")
	buf.WriteString("// Source: cloudformation-schema-go/enums\n")
	buf.WriteString(fmt.Sprintf("// Generated: %s\n\n", time.Now().Format(time.RFC3339)))
	buf.WriteString(fmt.Sprintf("package %s\n", svc.Name))

	// Sort enum names for deterministic output
	sort.Strings(enumNames)

	for _, enumName := range enumNames {
		values := enums.GetAllowedValues(svc.Name, enumName)
		if len(values) == 0 {
			continue
		}

		buf.WriteString(fmt.Sprintf("\n// %s represents valid values for %s.\n", enumName, enumName))
		buf.WriteString(fmt.Sprintf("type %s string\n\n", enumName))
		buf.WriteString("const (\n")

		for _, val := range values {
			constName := enumConstName(enumName, val)
			buf.WriteString(fmt.Sprintf("\t%s %s = %q\n", constName, enumName, val))
		}

		buf.WriteString(")\n")
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		formatted = buf.Bytes() // Use unformatted if formatting fails
	}

	enumsFile := filepath.Join(svcDir, "enums.go")
	if dryRun {
		fmt.Printf("Would write: %s (%d enums)\n", enumsFile, len(enumNames))
		return nil
	}

	if err := os.WriteFile(enumsFile, formatted, 0644); err != nil {
		return err
	}
	stats.FilesWritten++

	return nil
}

// enumConstName generates a Go constant name from an enum type and value.
// Examples:
//   - ("Runtime", "python3.12") -> "RuntimePython312"
//   - ("StorageClass", "STANDARD_IA") -> "StorageClassStandardIa"
//   - ("BucketCannedACL", "public-read") -> "BucketCannedACLPublicRead"
//   - ("ServerSideEncryption", "aws:kms") -> "ServerSideEncryptionAwsKms"
//   - ("Event", "s3:ObjectCreated:*") -> "EventS3ObjectcreatedAll"
//   - ("StandardUnit", "Bytes/Second") -> "StandardUnitBytesPerSecond"
func enumConstName(typeName, value string) string {
	// Split value by common separators and capitalize each part
	var result strings.Builder
	result.WriteString(typeName)

	// Replace common separators with spaces for splitting
	normalized := strings.ReplaceAll(value, "-", " ")
	normalized = strings.ReplaceAll(normalized, "_", " ")
	normalized = strings.ReplaceAll(normalized, ".", " ")
	normalized = strings.ReplaceAll(normalized, ":", " ")
	normalized = strings.ReplaceAll(normalized, "(", " ")
	normalized = strings.ReplaceAll(normalized, ")", " ")
	// Replace special characters with meaningful words
	normalized = strings.ReplaceAll(normalized, "*", "All")
	normalized = strings.ReplaceAll(normalized, "/", "Per")

	for _, part := range strings.Fields(normalized) {
		// Capitalize first letter, lowercase rest
		for i, r := range part {
			if i == 0 {
				result.WriteRune(unicode.ToUpper(r))
			} else {
				result.WriteRune(unicode.ToLower(r))
			}
		}
	}

	return result.String()
}
