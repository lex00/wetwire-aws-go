package main

import (
	"bytes"
	"go/format"
	"sort"
	"text/template"
	"time"
)

var propertyTypesTemplate = template.Must(template.New("types").Parse(`// Code generated by wetwire-aws codegen. DO NOT EDIT.
// Source: CloudFormation Resource Specification
// Generated: {{ .Timestamp }}

package {{ .PackageName }}
{{ if not .SkipTag }}
// Tag represents a CloudFormation tag.
// This is a shared type used across all services.
type Tag struct {
	Key   string ` + "`json:\"Key\"`" + `
	Value any    ` + "`json:\"Value\"`" + `
}
{{ end }}

{{ range .Types }}
{{ if .Documentation }}// {{ .Name }} represents {{ .CFType }}.
// {{ .Documentation }}
{{ else }}// {{ .Name }} represents {{ .CFType }}.
{{ end }}type {{ .Name }} struct {
{{ range .Properties }}{{ if .Documentation }}	// {{ .Documentation }}
{{ end }}	{{ .Name }} {{ .GoType }} ` + "`json:\"{{ .JSONName }},omitempty\"`" + `
{{ end }}}
{{ end }}
`))

type typesTemplateData struct {
	PackageName string
	Timestamp   string
	Types       []typeData
	SkipTag     bool // True if the service has a Tag resource (to avoid conflict)
}

type typeData struct {
	Name          string
	CFType        string
	Documentation string
	Properties    []propertyData
}

// generateSharedTypes generates types.go with only shared types (Tag).
func generateSharedTypes(svc *Service) []byte {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by wetwire-aws codegen. DO NOT EDIT.\n")
	buf.WriteString("// Source: CloudFormation Resource Specification\n")
	buf.WriteString("// Generated: " + time.Now().Format(time.RFC3339) + "\n\n")
	buf.WriteString("package " + svc.Name + "\n\n")
	buf.WriteString("// Tag represents a CloudFormation tag.\n")
	buf.WriteString("// This is a shared type used across all services.\n")
	buf.WriteString("type Tag struct {\n")
	buf.WriteString("\tKey   string `json:\"Key\"`\n")
	buf.WriteString("\tValue any    `json:\"Value\"`\n")
	buf.WriteString("}\n")
	return buf.Bytes()
}

// generateResourcePropertyTypes generates a {resource}_types.go file for property types of a single resource.
func generateResourcePropertyTypes(svc *Service, resourceName string, typeNames []string) ([]byte, error) {
	// Build qualified names map for type reference resolution.
	// The map key in svc.PropertyTypes is already qualified (e.g., "Bucket_PublicAccessBlockConfiguration").
	// Sort keys for deterministic ordering (alphabetically first wins for short names).
	qualifiedNames := make(map[string]string)
	sortedTypeKeys := make([]string, 0, len(svc.PropertyTypes))
	for k := range svc.PropertyTypes {
		sortedTypeKeys = append(sortedTypeKeys, k)
	}
	sort.Strings(sortedTypeKeys)
	for _, qualifiedKey := range sortedTypeKeys {
		propType := svc.PropertyTypes[qualifiedKey]
		// Map short name to qualified key (first alphabetically wins)
		if _, exists := qualifiedNames[propType.Name]; !exists {
			qualifiedNames[propType.Name] = qualifiedKey
		}
		// Also map qualified key to itself for explicit lookups
		qualifiedNames[qualifiedKey] = qualifiedKey
	}

	var types []typeData
	for _, qualifiedKey := range typeNames {
		propType := svc.PropertyTypes[qualifiedKey]
		// qualifiedKey is already "ResourceName_PropertyType"
		qualifiedName := qualifiedKey

		// Sort properties
		propNames := make([]string, 0, len(propType.Properties))
		for pn := range propType.Properties {
			propNames = append(propNames, pn)
		}
		sort.Strings(propNames)

		var props []propertyData
		for _, pn := range propNames {
			prop := propType.Properties[pn]
			goType := resolveTypeReferences(prop.GoType, qualifiedNames, prop.IsPointer)

			goName := pn
			if isGoKeyword(pn) {
				goName = pn + "_"
			}

			props = append(props, propertyData{
				Name:          goName,
				GoType:        goType,
				JSONName:      pn,
				Documentation: cleanDoc(prop.Documentation),
			})
		}

		types = append(types, typeData{
			Name:          qualifiedName,
			CFType:        propType.CFType,
			Documentation: cleanDoc(propType.Documentation),
			Properties:    props,
		})
	}

	data := typesTemplateData{
		PackageName: svc.Name,
		Timestamp:   time.Now().Format(time.RFC3339),
		Types:       types,
		SkipTag:     true, // Always skip Tag in per-resource files (it's in types.go)
	}

	var buf bytes.Buffer
	if err := propertyTypesTemplate.Execute(&buf, data); err != nil {
		return nil, err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.Bytes(), nil
	}

	return formatted, nil
}
