package importer

import (
	"regexp"
	"sort"
	"strings"
	"unicode"

	"github.com/lex00/wetwire-aws-go/resources"
)

// isPointerField checks if a property field expects a pointer type.
// Uses the PointerFields registry generated by codegen.
func isPointerField(ctx *codegenContext, propName string) bool {
	if propName == "" || ctx.currentTypeName == "" {
		return false
	}
	key := ctx.currentResource + "." + ctx.currentTypeName + "." + propName
	return resources.PointerFields[key]
}

// getPropertyTypeName returns the typed struct name for a property, if known.
// CloudFormation property types are always flat: {ResourceType}_{PropertyTypeName}
// e.g., Distribution_DistributionConfig, Distribution_DefaultCacheBehavior, Distribution_Cookies
// Returns empty string if the property should use map[string]any.
func getPropertyTypeName(ctx *codegenContext, propName string) string {
	if propName == "" || ctx.currentTypeName == "" {
		return ""
	}

	// Skip known fields that should remain as map[string]any or are handled specially
	skipFields := map[string]bool{
		"Tags":     true,
		"Metadata": true,
	}
	if skipFields[propName] {
		return ""
	}

	// First, check PropertyTypeMap for the exact mapping.
	// Format: "service.ResourceType.PropertyName" -> "ResourceType_ActualTypeName"
	// This handles cases where the property name differs from the type name.
	key := ctx.currentResource + "." + ctx.currentTypeName + "." + propName
	if typeName, ok := resources.PropertyTypeMap[key]; ok {
		return typeName
	}

	// CloudFormation property types are FLAT - they use the base resource type, not nested type.
	// e.g., Distribution_DistributionConfig has property Logging with type Distribution_Logging
	// NOT Distribution_DistributionConfig_Logging.
	// Extract base resource type from current type name.
	baseResourceType := ctx.currentTypeName
	if idx := strings.Index(ctx.currentTypeName, "_"); idx > 0 {
		baseResourceType = ctx.currentTypeName[:idx]
	}

	// Try flat pattern first: BaseResourceType_PropName
	flatTypeName := baseResourceType + "_" + propName
	fullName := ctx.currentResource + "." + flatTypeName
	if resources.PropertyTypes[fullName] {
		return flatTypeName
	}

	// Fallback: Try nested pattern (currentTypeName_propName) for rare cases
	nestedTypeName := ctx.currentTypeName + "_" + propName
	fullName = ctx.currentResource + "." + nestedTypeName
	if resources.PropertyTypes[fullName] {
		return nestedTypeName
	}

	// Type doesn't exist, fall back to map[string]any
	return ""
}

// getArrayElementTypeName returns the typed struct name for array elements.
// CloudFormation uses singular names for element types: Origins -> Origin
func getArrayElementTypeName(ctx *codegenContext, propName string) string {
	if propName == "" || ctx.currentTypeName == "" {
		return ""
	}

	// Skip known fields that should remain as []any
	skipFields := map[string]bool{
		"Tags": true,
	}
	if skipFields[propName] {
		return ""
	}

	// First, check PropertyTypeMap for the exact mapping.
	// Format: "service.ResourceType.PropertyName" -> "ResourceType_ActualTypeName"
	// This handles array properties where the type name differs from singular property name.
	// e.g., "s3.Bucket.AnalyticsConfigurations" -> "Bucket_AnalyticsConfiguration"
	key := ctx.currentResource + "." + ctx.currentTypeName + "." + propName
	if typeName, ok := resources.PropertyTypeMap[key]; ok {
		return typeName
	}

	singular := singularize(propName)

	// CloudFormation property types are FLAT - they use the base resource type, not nested type.
	// e.g., Distribution_DistributionConfig has property Origins with element type Distribution_Origin
	// NOT Distribution_DistributionConfig_Origin.
	// Extract base resource type from current type name.
	baseResourceType := ctx.currentTypeName
	if idx := strings.Index(ctx.currentTypeName, "_"); idx > 0 {
		baseResourceType = ctx.currentTypeName[:idx]
	}

	// Try flat pattern first: BaseResourceType_SingularPropName
	flatTypeName := baseResourceType + "_" + singular
	fullName := ctx.currentResource + "." + flatTypeName
	if resources.PropertyTypes[fullName] {
		return flatTypeName
	}

	// Fallback: Try nested pattern (currentTypeName_singular) for rare cases
	nestedTypeName := ctx.currentTypeName + "_" + singular
	fullName = ctx.currentResource + "." + nestedTypeName
	if resources.PropertyTypes[fullName] {
		return nestedTypeName
	}

	// Type doesn't exist, fall back to []any
	return ""
}

// singularize converts a plural property name to singular for element types.
// e.g., Origins -> Origin, CacheBehaviors -> CacheBehavior
func singularize(name string) string {
	// Handle common CloudFormation patterns
	if strings.HasSuffix(name, "ies") {
		// e.g., Policies -> Policy
		return name[:len(name)-3] + "y"
	}
	if strings.HasSuffix(name, "sses") {
		// e.g., Addresses -> Address (but keep one 's')
		return name[:len(name)-2]
	}
	if strings.HasSuffix(name, "s") && !strings.HasSuffix(name, "ss") {
		// e.g., Origins -> Origin, but keep Addresses as Address
		return name[:len(name)-1]
	}
	return name
}

// allKeysValidIdentifiers checks if all keys in a map are valid Go identifiers.
// Returns false if any key contains special characters like ':' or starts with a number.
func allKeysValidIdentifiers(m map[string]any) bool {
	for k := range m {
		if !isValidGoIdentifier(k) {
			return false
		}
	}
	return true
}

// isValidGoIdentifier checks if a string is a valid Go identifier.
func isValidGoIdentifier(s string) bool {
	if len(s) == 0 {
		return false
	}
	for i, r := range s {
		if i == 0 {
			if !unicode.IsLetter(r) && r != '_' {
				return false
			}
		} else {
			if !unicode.IsLetter(r) && !unicode.IsDigit(r) && r != '_' {
				return false
			}
		}
	}
	// Also check for Go keywords
	return !isGoKeyword(s)
}

// resolveResourceType maps a CloudFormation type to Go module and type names.
func resolveResourceType(cfType string) (module, typeName string) {
	parts := strings.Split(cfType, "::")
	if len(parts) != 3 || parts[0] != "AWS" {
		return "", ""
	}

	service := parts[1]
	resource := parts[2]

	// Map service name to Go module name
	module = strings.ToLower(service)

	typeName = resource

	return module, typeName
}

// topologicalSort returns resources in dependency order (dependencies first).
func topologicalSort(template *IRTemplate) []string {
	// Build dependency graph: node -> list of nodes it depends on
	deps := make(map[string][]string)
	for id := range template.Resources {
		deps[id] = nil
	}
	for source, targets := range template.ReferenceGraph {
		if _, ok := template.Resources[source]; !ok {
			continue
		}
		for _, target := range targets {
			if _, ok := template.Resources[target]; ok {
				// source depends on target
				deps[source] = append(deps[source], target)
			}
		}
	}

	// Kahn's algorithm - compute in-degree (nodes that depend on this one)
	inDegree := make(map[string]int)
	for id := range template.Resources {
		inDegree[id] = 0
	}
	// For each dependency edge, increment the in-degree of the dependent
	for id, idDeps := range deps {
		inDegree[id] = len(idDeps)
	}

	// Start with nodes that have no dependencies (in-degree 0)
	var queue []string
	for id, degree := range inDegree {
		if degree == 0 {
			queue = append(queue, id)
		}
	}
	sort.Strings(queue) // Stable order

	var result []string
	processed := make(map[string]bool)

	for len(queue) > 0 {
		// Take from front
		node := queue[0]
		queue = queue[1:]

		if processed[node] {
			continue
		}
		processed[node] = true
		result = append(result, node)

		// Find nodes that depend on this node
		for id, idDeps := range deps {
			if processed[id] {
				continue
			}
			for _, dep := range idDeps {
				if dep == node {
					inDegree[id]--
					if inDegree[id] == 0 {
						queue = append(queue, id)
					}
					break
				}
			}
		}
		sort.Strings(queue)
	}

	// Handle cycles by adding remaining nodes
	for id := range template.Resources {
		if !processed[id] {
			result = append(result, id)
		}
	}

	return result
}

// sortedKeys returns sorted keys from a map.
func sortedKeys[V any](m map[string]V) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

// ToSnakeCase converts PascalCase to snake_case.
func ToSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && unicode.IsUpper(r) {
			result.WriteRune('_')
		}
		result.WriteRune(unicode.ToLower(r))
	}
	return result.String()
}

// ToPascalCase converts snake_case to PascalCase.
func ToPascalCase(s string) string {
	words := regexp.MustCompile(`[_\-\s]+`).Split(s, -1)
	var result strings.Builder
	for _, word := range words {
		if len(word) > 0 {
			result.WriteString(strings.ToUpper(string(word[0])))
			if len(word) > 1 {
				result.WriteString(strings.ToLower(word[1:]))
			}
		}
	}
	return result.String()
}

// SanitizeGoName ensures a name is a valid Go identifier.
// Also capitalizes the first letter to ensure the variable is exported.
func SanitizeGoName(name string) string {
	// Remove invalid characters
	var result strings.Builder
	for i, r := range name {
		if i == 0 {
			if unicode.IsLetter(r) || r == '_' {
				// Capitalize first letter for export
				result.WriteRune(unicode.ToUpper(r))
			} else if unicode.IsDigit(r) {
				// Names starting with digits need a letter prefix to be valid Go identifiers
				// Use "N" (for Number) instead of "_" to keep the variable exported
				result.WriteRune('N')
				result.WriteRune(r)
			} else {
				result.WriteRune('_')
			}
		} else {
			if unicode.IsLetter(r) || unicode.IsDigit(r) || r == '_' {
				result.WriteRune(r)
			}
		}
	}

	s := result.String()
	if s == "" {
		return "_"
	}

	// Check for Go keywords
	if isGoKeyword(s) {
		return s + "_"
	}

	return s
}

// goKeywords and isGoKeyword are defined in parser.go
