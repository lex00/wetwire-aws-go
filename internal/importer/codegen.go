// Package importer converts CloudFormation YAML/JSON templates to Go source code.
//
// The importer parses CloudFormation templates into an intermediate representation (IR),
// then generates idiomatic Go code that uses the wetwire-aws resource types.
//
// # Usage
//
// Import a template and generate Go code:
//
//	template, err := importer.ParseTemplate("template.yaml")
//	if err != nil {
//	    log.Fatal(err)
//	}
//	files := importer.GenerateCode(template, "mystack")
//	for name, content := range files {
//	    os.WriteFile(name, []byte(content), 0644)
//	}
//
// # Generated Code Structure
//
// The importer generates multiple Go files organized by AWS service category:
//   - params.go: CloudFormation parameters
//   - outputs.go: Stack outputs
//   - security.go: IAM roles, policies, KMS keys
//   - network.go: VPC, subnets, security groups
//   - compute.go: EC2, Lambda functions
//   - storage.go: S3 buckets, EFS
//   - database.go: RDS, DynamoDB
//   - main.go: Other resources
//
// # Code Style
//
// Generated code follows the wetwire-aws declarative patterns:
//   - Package-level var declarations for resources
//   - Direct variable references instead of explicit Ref{}/GetAtt{}
//   - Extracted nested types as separate variables
//   - Typed intrinsics using the intrinsics package
package importer

import (
	"fmt"
	"runtime/debug"
	"sort"
	"strings"
)

// getModuleVersion returns the version of wetwire-aws-go.
// Uses build info if available, otherwise returns "latest".
func getModuleVersion() string {
	if info, ok := debug.ReadBuildInfo(); ok {
		// When running as part of wetwire-aws-go, check main module
		if info.Main.Version != "" && info.Main.Version != "(devel)" {
			return info.Main.Version
		}
		// Also check dependencies in case this is embedded
		for _, dep := range info.Deps {
			if dep.Path == "github.com/lex00/wetwire-aws-go" {
				if dep.Version != "" && dep.Version != "(devel)" {
					return dep.Version
				}
			}
		}
	}
	return "latest"
}

// serviceCategories maps AWS service names to file categories.
// This matches the Python implementation in linter/splitting.py.
// These are optional files that help set up a complete Go project.
func GenerateTemplateFiles(packageName string, modulePath string) map[string]string {
	files := make(map[string]string)

	// go.mod
	if modulePath == "" {
		modulePath = packageName
	}
	files["go.mod"] = fmt.Sprintf(`module %s

go 1.23.0

require (
	github.com/lex00/cloudformation-schema-go v1.0.0
	github.com/lex00/wetwire-aws-go %s
)
`, modulePath, getModuleVersion())

	// cmd/main.go - Entry point placeholder
	// Note: The actual synthesis is done via `wetwire-aws build`
	files["cmd/main.go"] = `package main

import "fmt"

func main() {
	// Build this template using the wetwire-aws CLI:
	//   wetwire-aws build .
	//
	// This generates template.json from the Go resource definitions.
	fmt.Println("Usage: wetwire-aws build .")
}
`

	// .gitignore
	files[".gitignore"] = `# Build output
template.json
template.yaml
*.out

# Go
*.exe
*.exe~
*.dll
*.so
*.dylib
*.test

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
`

	// README.md - Project documentation
	files["README.md"] = fmt.Sprintf(`# %s

CloudFormation infrastructure as Go code, generated by [wetwire-aws](https://github.com/lex00/wetwire-aws-go).

## Prerequisites

- Go 1.22+
- wetwire-aws CLI

## Quick Start

`+"`"+`bash
# Build the CloudFormation template
wetwire-aws build .

# Or run directly
cd cmd && go run main.go > template.json

# Deploy with AWS CLI
aws cloudformation deploy \
  --template-file template.json \
  --stack-name %s \
  --capabilities CAPABILITY_IAM
`+"`"+`

## Project Structure

| File | Description |
|------|-------------|
| `+"`params.go`"+` | CloudFormation parameters and conditions |
| `+"`outputs.go`"+` | Stack outputs |
| `+"`security.go`"+` | IAM roles, policies, KMS keys |
| `+"`network.go`"+` | VPC, subnets, security groups, load balancers |
| `+"`compute.go`"+` | EC2 instances, Lambda functions |
| `+"`storage.go`"+` | S3 buckets, EFS |
| `+"`database.go`"+` | RDS, DynamoDB |
| `+"`main.go`"+` | Other resources |

## Modifying Resources

Resources are defined as Go struct literals:

`+"`"+`go
var MyBucket = s3.Bucket{
    BucketName: Sub{String: "${AppName}-bucket-${Environment}"},
    Tags: []any{MyBucketTagName, MyBucketTagEnv},
}
`+"`"+`

Cross-resource references use direct variable names:

`+"`"+`go
var MyPolicy = s3.BucketPolicy{
    Bucket: MyBucket,  // References the bucket above
}
`+"`"+`

## License

[Add your license here]
`, packageName, packageName)

	// CLAUDE.md - Instructions for Claude Code
	files["CLAUDE.md"] = fmt.Sprintf(`# %s Infrastructure

This package contains CloudFormation resources generated by wetwire-aws.

## Structure

- `+"`params.go`"+` - CloudFormation parameters and conditions
- `+"`outputs.go`"+` - Stack outputs
- `+"`security.go`"+` - IAM roles, policies, KMS keys
- `+"`network.go`"+` - VPC, subnets, security groups, load balancers
- `+"`compute.go`"+` - EC2 instances, Lambda functions
- `+"`storage.go`"+` - S3 buckets, EFS
- `+"`database.go`"+` - RDS, DynamoDB
- `+"`main.go`"+` - Other resources

## Usage

### Build the template
`+"`"+`bash
cd cmd && go run main.go > template.json
`+"`"+`

### Or use wetwire-aws CLI
`+"`"+`bash
wetwire-aws build .
`+"`"+`

## Modifying Resources

Each resource is defined as a Go struct. For example:

`+"`"+`go
var MyBucket = s3.Bucket{
    BucketName: "my-bucket",
}
`+"`"+`

Cross-resource references use direct variable references:

`+"`"+`go
var MyPolicy = s3.BucketPolicy{
    Bucket: MyBucket,  // Reference to another resource
}
`+"`"+`

## Intrinsic Functions

Import from `+"`github.com/lex00/wetwire-aws-go/intrinsics`"+`:

`+"`"+`go
import . "github.com/lex00/wetwire-aws-go/intrinsics"

var MyRole = iam.Role{
    RoleName: Sub{String: "${AppName}-role-${Environment}"},
}
`+"`"+`
`, packageName)

	return files
}

// GenerateCode generates Go code from a parsed IR template.
// Returns a map of filename to content.
// Files are split by category:
//   - params.go: Parameters + Conditions
//   - outputs.go: Outputs
//   - security.go: IAM, Cognito, KMS, etc.
//   - network.go: VPC, Subnets, ELB, CloudFront, etc.
//   - compute.go: EC2 Instances, Lambda, ECS, etc.
//   - storage.go: S3, EFS, etc.
//   - database.go: RDS, DynamoDB, etc.
//   - messaging.go: SNS, SQS, EventBridge, etc.
//   - monitoring.go: CloudWatch, Logs, etc.
//   - main.go: Mappings + uncategorized resources
func GenerateCode(template *IRTemplate, packageName string) map[string]string {
	ctx := newCodegenContext(template, packageName)

	// Generate multi-file output
	files := make(map[string]string)

	// First pass: categorize resources
	resourcesByCategory := make(map[string][]string)
	for _, resourceID := range ctx.resourceOrder {
		resource := ctx.template.Resources[resourceID]
		category := categorizeResourceType(resource.ResourceType)
		resourcesByCategory[category] = append(resourcesByCategory[category], resourceID)
	}

	// Second pass: generate resources by category to track parameter usage and collect imports
	categoryCode := make(map[string]string)
	categoryImports := make(map[string]map[string]bool)

	for category, resourceIDs := range resourcesByCategory {
		code, imports := generateResourcesByIDs(ctx, resourceIDs)
		categoryCode[category] = code
		categoryImports[category] = imports
	}

	// Pre-scan all expressions for parameter references before generating params
	// This ensures parameters used in conditions, resources, and Sub strings are included
	prescanAllForParams(ctx)

	// Generate params.go if there are used parameters or conditions
	paramsCode, paramsImports := generateParams(ctx)
	conditionsCode := generateConditions(ctx)
	if paramsCode != "" || conditionsCode != "" {
		combined := paramsCode
		if conditionsCode != "" {
			if combined != "" {
				combined += "\n\n"
			}
			combined += conditionsCode
		}
		files["params.go"] = buildFile(ctx.packageName, "Parameters and Conditions", paramsImports, combined)
	}

	// Generate outputs.go if there are outputs
	if outputsCode, outputsImports := generateOutputs(ctx); outputsCode != "" {
		files["outputs.go"] = buildFile(ctx.packageName, "Outputs", outputsImports, outputsCode)
	}

	// Generate category files
	categoryDescriptions := map[string]string{
		"security":   "Security resources: IAM, Cognito, KMS, etc.",
		"network":    "Network resources: VPC, Subnets, Load Balancers, CloudFront, etc.",
		"compute":    "Compute resources: EC2, Lambda, ECS, etc.",
		"storage":    "Storage resources: S3, EFS, etc.",
		"database":   "Database resources: RDS, DynamoDB, etc.",
		"messaging":  "Messaging resources: SNS, SQS, EventBridge, etc.",
		"monitoring": "Monitoring resources: CloudWatch, Logs, etc.",
		"cicd":       "CI/CD resources: CodeBuild, CodePipeline, etc.",
		"infra":      "Infrastructure resources: CloudFormation, Config, etc.",
		"main":       "Main resources",
	}

	for category, code := range categoryCode {
		if code == "" {
			continue
		}

		imports := categoryImports[category]
		description := categoryDescriptions[category]
		if description == "" {
			description = category + " resources"
		}

		// Add mappings to main file only
		if category == "main" {
			if mappingsCode := generateMappings(ctx); mappingsCode != "" {
				code = mappingsCode + "\n\n" + code
			}
		}

		// Remove intrinsics import if the code doesn't actually use any intrinsic types
		// Resource/parameter references resolve to direct variable names, not intrinsic types
		if imports["github.com/lex00/wetwire-aws-go/intrinsics"] && !codeUsesIntrinsics(code) {
			delete(imports, "github.com/lex00/wetwire-aws-go/intrinsics")
		}

		filename := category + ".go"
		files[filename] = buildFile(ctx.packageName, description, imports, code)
	}

	// If there are only mappings and no main resources, still generate main.go
	if _, hasMain := categoryCode["main"]; !hasMain {
		if mappingsCode := generateMappings(ctx); mappingsCode != "" {
			imports := make(map[string]bool)
			if codeUsesIntrinsics(mappingsCode) {
				imports["github.com/lex00/wetwire-aws-go/intrinsics"] = true
			}
			files["main.go"] = buildFile(ctx.packageName, "Mappings", imports, mappingsCode)
		}
	}

	return files
}

// codeUsesIntrinsics checks if generated code actually uses intrinsic types.
// Resource/parameter references resolve to direct variable names, not intrinsic types,
// so we need to check if any intrinsic struct types are present in the code.
func codeUsesIntrinsics(code string) bool {
	intrinsicTypes := []string{
		"Sub{", "SubWithMap{", "Ref{", "GetAtt{", "Join{", "Select{", "GetAZs{",
		"If{", "Equals{", "And{", "Or{", "Not{", "FindInMap{", "Split{", "Cidr{",
		"Condition{", "ImportValue{", "Transform{", "Json{", "Parameter{", "Output{",
		"AWS_REGION", "AWS_ACCOUNT_ID", "AWS_STACK_NAME", "AWS_STACK_ID",
		"AWS_PARTITION", "AWS_URL_SUFFIX", "AWS_NO_VALUE", "AWS_NOTIFICATION_ARNS",
		"PolicyDocument{", "PolicyStatement{", "DenyStatement{", "AllowStatement{",
		"ServicePrincipal{", "AWSPrincipal{", "FederatedPrincipal{", "Tag{",
	}
	for _, t := range intrinsicTypes {
		if strings.Contains(code, t) {
			return true
		}
	}
	return false
}

// buildFile constructs a complete Go source file.
func buildFile(packageName, description string, imports map[string]bool, code string) string {
	var sections []string

	// Package header
	header := fmt.Sprintf("// Package %s contains CloudFormation resources.\n", packageName)
	if description != "" {
		header += fmt.Sprintf("// %s\n", description)
	}
	header += "//\n// Generated by wetwire-aws import.\n"
	header += fmt.Sprintf("package %s", packageName)
	sections = append(sections, header)

	// Imports
	if len(imports) > 0 {
		var importLines []string
		sortedImports := sortedKeys(imports)
		for _, imp := range sortedImports {
			if imp == "github.com/lex00/wetwire-aws-go/intrinsics" {
				importLines = append(importLines, fmt.Sprintf("\t. %q", imp))
			} else {
				importLines = append(importLines, fmt.Sprintf("\t%q", imp))
			}
		}
		sections = append(sections, fmt.Sprintf("import (\n%s\n)", strings.Join(importLines, "\n")))
	}

	// Code
	sections = append(sections, code)

	return strings.Join(sections, "\n\n") + "\n"
}

// generateParams generates parameter declarations and returns code + imports.
func generateParams(ctx *codegenContext) (string, map[string]bool) {
	imports := make(map[string]bool)
	var sections []string

	for _, logicalID := range sortedKeys(ctx.template.Parameters) {
		if !ctx.usedParameters[logicalID] {
			continue
		}
		param := ctx.template.Parameters[logicalID]
		sections = append(sections, generateParameter(ctx, param))
		imports["github.com/lex00/wetwire-aws-go/intrinsics"] = true
	}

	return strings.Join(sections, "\n\n"), imports
}

// generateOutputs generates output declarations and returns code + imports.
func generateOutputs(ctx *codegenContext) (string, map[string]bool) {
	imports := make(map[string]bool)

	var sections []string
	for _, logicalID := range sortedKeys(ctx.template.Outputs) {
		output := ctx.template.Outputs[logicalID]
		sections = append(sections, generateOutput(ctx, output))
	}

	if len(sections) == 0 {
		return "", nil
	}

	// Output type requires intrinsics import
	imports["github.com/lex00/wetwire-aws-go/intrinsics"] = true

	return strings.Join(sections, "\n\n"), imports
}

// generateResourcesByIDs generates resource declarations for specific resource IDs.
// Returns code and imports for just those resources.
func generateResourcesByIDs(ctx *codegenContext, resourceIDs []string) (string, map[string]bool) {
	// Save and reset imports for this category
	savedImports := ctx.imports
	ctx.imports = make(map[string]bool)

	var sections []string
	for _, resourceID := range resourceIDs {
		resource := ctx.template.Resources[resourceID]
		sections = append(sections, generateResource(ctx, resource))
	}

	// Capture category imports
	categoryImports := ctx.imports

	// Merge into saved imports (for cross-category reference tracking)
	for imp := range categoryImports {
		savedImports[imp] = true
	}
	ctx.imports = savedImports

	return strings.Join(sections, "\n\n"), categoryImports
}

// prescanAllForParams scans all expressions (conditions, resources, outputs) for
// parameter references and marks them as used. This must be called before
// generateParams to ensure all referenced parameters are included.
func prescanAllForParams(ctx *codegenContext) {
	// Scan conditions
	for _, condition := range ctx.template.Conditions {
		scanExprForParams(ctx, condition.Expression)
	}

	// Scan all resources
	for _, resource := range ctx.template.Resources {
		for _, prop := range resource.Properties {
			scanExprForParams(ctx, prop.Value)
		}
	}

	// Scan outputs
	for _, output := range ctx.template.Outputs {
		scanExprForParams(ctx, output.Value)
		if output.Condition != "" {
			// Condition name itself isn't a param, but scan anyway
			scanExprForParams(ctx, output.Condition)
		}
	}
}

// scanExprForParams recursively scans an expression for parameter references.
// Handles Ref intrinsics and parameter names embedded in Sub strings.
func scanExprForParams(ctx *codegenContext, expr any) {
	switch v := expr.(type) {
	case *IRIntrinsic:
		switch v.Type {
		case IntrinsicRef:
			target := fmt.Sprintf("%v", v.Args)
			if _, ok := ctx.template.Parameters[target]; ok {
				ctx.usedParameters[target] = true
			}
		case IntrinsicSub:
			// Extract parameter names from Sub string
			scanSubStringForParams(ctx, v.Args)
		}
		// Recurse into intrinsic args
		scanExprForParams(ctx, v.Args)
	case []any:
		for _, elem := range v {
			scanExprForParams(ctx, elem)
		}
	case map[string]any:
		for _, val := range v {
			scanExprForParams(ctx, val)
		}
	case string:
		// Check if string contains ${ParamName} references (shouldn't happen outside Sub, but be safe)
		scanSubStringForParams(ctx, v)
	}
}

// scanSubStringForParams extracts parameter references from a Sub template string.
// Sub strings can contain ${ParamName} or ${AWS::PseudoParam} references.
func scanSubStringForParams(ctx *codegenContext, args any) {
	var template string

	switch v := args.(type) {
	case string:
		template = v
	case []any:
		if len(v) > 0 {
			if s, ok := v[0].(string); ok {
				template = s
			}
		}
	default:
		return
	}

	// Extract all ${...} references from the template string
	// Pattern: ${VarName} where VarName doesn't start with AWS::
	for i := 0; i < len(template); i++ {
		if i+1 < len(template) && template[i] == '$' && template[i+1] == '{' {
			// Find closing brace
			end := strings.Index(template[i:], "}")
			if end == -1 {
				break
			}
			ref := template[i+2 : i+end]

			// Skip pseudo-parameters and attribute references
			if !strings.HasPrefix(ref, "AWS::") && !strings.Contains(ref, ".") {
				// Check if this is a known parameter
				if _, ok := ctx.template.Parameters[ref]; ok {
					ctx.usedParameters[ref] = true
				}
			}
			i = i + end
		}
	}
}

// generateConditions generates condition declarations.
func generateConditions(ctx *codegenContext) string {
	var sections []string
	for _, logicalID := range sortedKeys(ctx.template.Conditions) {
		condition := ctx.template.Conditions[logicalID]
		sections = append(sections, generateCondition(ctx, condition))
	}
	return strings.Join(sections, "\n\n")
}

// generateMappings generates mapping declarations.
func generateMappings(ctx *codegenContext) string {
	var sections []string
	for _, logicalID := range sortedKeys(ctx.template.Mappings) {
		mapping := ctx.template.Mappings[logicalID]
		sections = append(sections, generateMapping(ctx, mapping))
	}
	return strings.Join(sections, "\n\n")
}

// codegenContext holds state during code generation.
type codegenContext struct {
	template         *IRTemplate
	packageName      string
	imports          map[string]bool // import path -> true
	resourceOrder    []string        // topologically sorted resource IDs
	currentResource  string          // current resource module being generated (e.g., "ec2", "cloudfront")
	currentTypeName  string          // current resource type name (e.g., "Distribution", "VPC")
	currentProperty  string          // current property being generated (e.g., "SecurityGroupIngress")
	currentLogicalID string          // current resource's logical ID (e.g., "SecurityGroup")

	// Block-style property type declarations
	// Each property type instance becomes its own var declaration
	propertyBlocks []propertyBlock // collected during resource traversal
	blockNameCount map[string]int  // for generating unique names

	// Track which parameters are directly referenced via Ref
	usedParameters map[string]bool

	// Track unknown resource types (placeholders) - GetAtt must use explicit GetAtt{} for these
	unknownResources map[string]bool

	// Track which GetAtt references would create initialization cycles
	// Key is "sourceLogicalID:targetLogicalID", value is true if this reference is cyclic
	cyclicGetAttRefs map[string]bool
}

// propertyBlock represents a top-level var declaration for a property type instance.
type propertyBlock struct {
	varName    string         // e.g., "LoggingBucketBucketEncryption"
	typeName   string         // e.g., "s3.Bucket_BucketEncryption"
	properties map[string]any // property key-value pairs for generation
	isPointer  bool           // whether this should be a pointer type (&Type{})
	order      int            // insertion order for stable sorting
}

func newCodegenContext(template *IRTemplate, packageName string) *codegenContext {
	ctx := &codegenContext{
		template:         template,
		packageName:      packageName,
		imports:          make(map[string]bool),
		blockNameCount:   make(map[string]int),
		usedParameters:   make(map[string]bool),
		unknownResources: make(map[string]bool),
		cyclicGetAttRefs: make(map[string]bool),
	}

	// Topologically sort resources
	ctx.resourceOrder = topologicalSort(template)

	// Pre-scan for unknown resource types so GetAtt can use explicit GetAtt{} for them
	for _, res := range template.Resources {
		module, _ := resolveResourceType(res.ResourceType)
		if module == "" {
			ctx.unknownResources[res.LogicalID] = true
		}
	}

	// Pre-scan for SAM implicit resources
	// SAM auto-generates resources that aren't in the template but may be referenced
	detectSAMImplicitResources(ctx)

	// Detect initialization cycles and mark GetAtt references that need explicit form
	detectInitializationCycles(ctx)

	return ctx
}

// detectSAMImplicitResources identifies resources that SAM auto-generates
// (like IAM roles for Lambda functions) and adds them to unknownResources.
// This allows the importer to generate valid code for outputs that reference
// these implicit resources using explicit Ref{}/GetAtt{} forms.
func detectSAMImplicitResources(ctx *codegenContext) {
	for _, res := range ctx.template.Resources {
		switch res.ResourceType {
		case "AWS::Serverless::Function":
			// SAM auto-generates {FunctionName}Role for Lambda functions
			// unless AutoPublishAlias or Role property is explicitly set
			roleLogicalID := res.LogicalID + "Role"
			ctx.unknownResources[roleLogicalID] = true
		case "AWS::Serverless::Api":
			// SAM may create implicit deployment and stages
			ctx.unknownResources[res.LogicalID+"Deployment"] = true
			ctx.unknownResources[res.LogicalID+"Stage"] = true
		case "AWS::Serverless::HttpApi":
			// Similar implicit resources for HTTP API
			ctx.unknownResources[res.LogicalID+"ApiGatewayDefaultStage"] = true
		}
	}
}

// detectInitializationCycles detects cycles in the resource dependency graph
// and marks GetAtt references that should use explicit GetAtt{} form to break cycles.
// Go doesn't allow initialization cycles in package-level variables, so we need to
// break cycles by using GetAtt{} (string literals) instead of Resource.Attr (variable references).
func detectInitializationCycles(ctx *codegenContext) {
	// Build extended dependency graph including both direct Ref and GetAtt references
	// The ReferenceGraph from parsing already contains these
	deps := ctx.template.ReferenceGraph

	// Find all cycles using DFS
	cycles := findCycles(deps)

	// For each cycle, we need to break it by marking one GetAtt reference as cyclic
	// We prefer to break GetAtt references (attribute access) over Ref (variable references)
	// because GetAtt{"Resource", "Attr"} is a cleaner way to break cycles
	for _, cycle := range cycles {
		// Find a GetAtt edge in the cycle to break
		// For simplicity, break the first edge that we can identify as a GetAtt
		for i := 0; i < len(cycle); i++ {
			source := cycle[i]
			target := cycle[(i+1)%len(cycle)]
			// Mark this as a cyclic reference
			key := source + ":" + target
			ctx.cyclicGetAttRefs[key] = true
		}
	}
}

// findCycles finds all cycles in a directed graph using DFS.
// Returns a list of cycles, where each cycle is a list of node IDs.
func findCycles(graph map[string][]string) [][]string {
	var cycles [][]string
	visited := make(map[string]bool)
	recStack := make(map[string]bool)
	parent := make(map[string]string)

	var dfs func(node string, path []string)
	dfs = func(node string, path []string) {
		visited[node] = true
		recStack[node] = true
		path = append(path, node)

		for _, neighbor := range graph[node] {
			if !visited[neighbor] {
				parent[neighbor] = node
				dfs(neighbor, path)
			} else if recStack[neighbor] {
				// Found a cycle - extract it
				var cycle []string
				// Find where the cycle starts in the current path
				for i, n := range path {
					if n == neighbor {
						cycle = append(cycle, path[i:]...)
						break
					}
				}
				if len(cycle) > 1 {
					cycles = append(cycles, cycle)
				}
			}
		}

		recStack[node] = false
	}

	// Run DFS from all nodes to find all cycles
	for node := range graph {
		if !visited[node] {
			dfs(node, nil)
		}
	}

	return cycles
}

func generateParameter(ctx *codegenContext, param *IRParameter) string {
	var lines []string

	// Capitalize parameter name to ensure it's exported
	varName := sanitizeVarName(param.LogicalID)
	if param.Description != "" {
		// Wrap long descriptions to avoid multi-line comment issues
		desc := wrapComment(param.Description, 80)
		lines = append(lines, fmt.Sprintf("// %s - %s", varName, desc))
	}

	// Generate full Parameter{} struct with all metadata
	ctx.imports["github.com/lex00/wetwire-aws-go/intrinsics"] = true
	lines = append(lines, fmt.Sprintf("var %s = Parameter{", varName))

	// Type is required
	paramType := param.Type
	if paramType == "" {
		paramType = "String"
	}
	lines = append(lines, fmt.Sprintf("\tType: %q,", paramType))

	if param.Description != "" {
		lines = append(lines, fmt.Sprintf("\tDescription: %q,", param.Description))
	}
	if param.Default != nil {
		defaultVal := valueToGo(ctx, param.Default, 1)
		lines = append(lines, fmt.Sprintf("\tDefault: %s,", defaultVal))
	}
	if len(param.AllowedValues) > 0 {
		var vals []string
		for _, v := range param.AllowedValues {
			vals = append(vals, valueToGo(ctx, v, 0))
		}
		lines = append(lines, fmt.Sprintf("\tAllowedValues: []any{%s},", strings.Join(vals, ", ")))
	}
	if param.AllowedPattern != "" {
		lines = append(lines, fmt.Sprintf("\tAllowedPattern: %q,", param.AllowedPattern))
	}
	if param.ConstraintDescription != "" {
		lines = append(lines, fmt.Sprintf("\tConstraintDescription: %q,", param.ConstraintDescription))
	}
	if param.MinLength != nil {
		lines = append(lines, fmt.Sprintf("\tMinLength: IntPtr(%d),", *param.MinLength))
	}
	if param.MaxLength != nil {
		lines = append(lines, fmt.Sprintf("\tMaxLength: IntPtr(%d),", *param.MaxLength))
	}
	if param.MinValue != nil {
		lines = append(lines, fmt.Sprintf("\tMinValue: Float64Ptr(%g),", *param.MinValue))
	}
	if param.MaxValue != nil {
		lines = append(lines, fmt.Sprintf("\tMaxValue: Float64Ptr(%g),", *param.MaxValue))
	}
	if param.NoEcho {
		lines = append(lines, "\tNoEcho: true,")
	}

	lines = append(lines, "}")

	return strings.Join(lines, "\n")
}

// wrapComment truncates or wraps a comment to fit on a single line.
func wrapComment(s string, maxLen int) string {
	// Replace newlines with spaces
	s = strings.ReplaceAll(s, "\n", " ")
	s = strings.ReplaceAll(s, "\r", " ")
	// Collapse multiple spaces
	s = strings.Join(strings.Fields(s), " ")
	// Truncate if too long
	if len(s) > maxLen {
		s = s[:maxLen-3] + "..."
	}
	return s
}

func generateMapping(ctx *codegenContext, mapping *IRMapping) string {
	varName := mapping.LogicalID + "Mapping"
	value := valueToGo(ctx, mapping.MapData, 0)
	return fmt.Sprintf("var %s = %s", varName, value)
}

func generateCondition(ctx *codegenContext, condition *IRCondition) string {
	varName := SanitizeGoName(condition.LogicalID) + "Condition"
	value := valueToGo(ctx, condition.Expression, 0)
	return fmt.Sprintf("var %s = %s", varName, value)
}

func generateResource(ctx *codegenContext, resource *IRResource) string {
	var lines []string

	// Resolve resource type to Go module and type
	module, typeName := resolveResourceType(resource.ResourceType)
	if module == "" {
		// Generate placeholder variable for unknown resource types so they can still be referenced
		// This allows outputs and other resources to reference custom resources like Custom::*
		varName := sanitizeVarName(resource.LogicalID)
		return fmt.Sprintf("// %s is a placeholder for unknown resource type: %s\n// This allows references from outputs and other resources to compile.\nvar %s any = nil",
			varName, resource.ResourceType, varName)
	}

	// Add import
	ctx.imports[fmt.Sprintf("github.com/lex00/wetwire-aws-go/resources/%s", module)] = true

	// Set current resource context for typed property generation
	ctx.currentResource = module
	ctx.currentTypeName = typeName
	ctx.currentLogicalID = resource.LogicalID

	// Clear property blocks for this resource
	ctx.propertyBlocks = nil

	// First pass: collect top-level property blocks and resource property values
	// This populates ctx.propertyBlocks with typed property instances
	resourceProps := make(map[string]string) // GoName -> generated value (var reference or literal)
	for _, propName := range sortedKeys(resource.Properties) {
		prop := resource.Properties[propName]
		ctx.currentProperty = propName
		var value string
		if propName == "Tags" {
			value = tagsToBlockStyle(ctx, prop.Value)
		} else {
			// Check if this is a typed property
			value = valueToBlockStyleProperty(ctx, prop.Value, propName, resource.LogicalID)
		}
		resourceProps[prop.GoName] = value
	}

	// Process property blocks to generate their code
	// Blocks may add more blocks when processed, so we iterate until stable
	processedBlocks := make(map[int]string) // order -> generated code
	for {
		foundNew := false
		for i := range ctx.propertyBlocks {
			if _, done := processedBlocks[ctx.propertyBlocks[i].order]; done {
				continue
			}
			foundNew = true
			// Generate this block's code (may add more blocks to ctx.propertyBlocks)
			processedBlocks[ctx.propertyBlocks[i].order] = generatePropertyBlock(ctx, ctx.propertyBlocks[i])
		}
		if !foundNew {
			break
		}
	}

	// Output blocks in reverse order (dependencies first, deepest nesting first)
	// We use order field which increases as blocks are discovered during traversal
	// Later orders mean nested blocks, which should be output first
	sortedOrders := make([]int, 0, len(processedBlocks))
	for order := range processedBlocks {
		sortedOrders = append(sortedOrders, order)
	}
	sort.Sort(sort.Reverse(sort.IntSlice(sortedOrders)))

	for _, order := range sortedOrders {
		lines = append(lines, processedBlocks[order])
		lines = append(lines, "") // blank line between blocks
	}

	varName := sanitizeVarName(resource.LogicalID)

	// Build struct literal for the resource
	lines = append(lines, fmt.Sprintf("var %s = %s.%s{", varName, module, typeName))

	// Properties (in sorted order)
	for _, propName := range sortedKeys(resource.Properties) {
		prop := resource.Properties[propName]
		value := resourceProps[prop.GoName]
		lines = append(lines, fmt.Sprintf("\t%s: %s,", prop.GoName, value))
	}

	lines = append(lines, "}")

	return strings.Join(lines, "\n")
}


