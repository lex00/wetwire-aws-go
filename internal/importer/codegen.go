// Package importer converts CloudFormation YAML/JSON templates to Go source code.
//
// The importer parses CloudFormation templates into an intermediate representation (IR),
// then generates idiomatic Go code that uses the wetwire-aws resource types.
//
// # Usage
//
// Import a template and generate Go code:
//
//	template, err := importer.ParseTemplate("template.yaml")
//	if err != nil {
//	    log.Fatal(err)
//	}
//	files := importer.GenerateCode(template, "mystack")
//	for name, content := range files {
//	    os.WriteFile(name, []byte(content), 0644)
//	}
//
// # Generated Code Structure
//
// The importer generates multiple Go files organized by AWS service category:
//   - params.go: CloudFormation parameters
//   - outputs.go: Stack outputs
//   - security.go: IAM roles, policies, KMS keys
//   - network.go: VPC, subnets, security groups
//   - compute.go: EC2, Lambda functions
//   - storage.go: S3 buckets, EFS
//   - database.go: RDS, DynamoDB
//   - main.go: Other resources
//
// # Code Style
//
// Generated code follows the wetwire-aws declarative patterns:
//   - Package-level var declarations for resources
//   - Direct variable references instead of explicit Ref{}/GetAtt{}
//   - Extracted nested types as separate variables
//   - Typed intrinsics using the intrinsics package
package importer

import (
	"fmt"
	"runtime/debug"
	"strings"
)

// getModuleVersion returns the version of wetwire-aws-go.
// Uses build info if available, otherwise returns "latest".
func getModuleVersion() string {
	if info, ok := debug.ReadBuildInfo(); ok {
		// When running as part of wetwire-aws-go, check main module
		if info.Main.Version != "" && info.Main.Version != "(devel)" {
			return info.Main.Version
		}
		// Also check dependencies in case this is embedded
		for _, dep := range info.Deps {
			if dep.Path == "github.com/lex00/wetwire-aws-go" {
				if dep.Version != "" && dep.Version != "(devel)" {
					return dep.Version
				}
			}
		}
	}
	return "latest"
}

// serviceCategories maps AWS service names to file categories.
// This matches the Python implementation in linter/splitting.py.
// These are optional files that help set up a complete Go project.
func GenerateTemplateFiles(packageName string, modulePath string) map[string]string {
	files := make(map[string]string)

	// go.mod
	if modulePath == "" {
		modulePath = packageName
	}
	files["go.mod"] = fmt.Sprintf(`module %s

go 1.23.0

require (
	github.com/lex00/cloudformation-schema-go v1.0.0
	github.com/lex00/wetwire-aws-go %s
)
`, modulePath, getModuleVersion())

	// cmd/main.go - Entry point placeholder
	// Note: The actual synthesis is done via `wetwire-aws build`
	files["cmd/main.go"] = `package main

import "fmt"

func main() {
	// Build this template using the wetwire-aws CLI:
	//   wetwire-aws build .
	//
	// This generates template.json from the Go resource definitions.
	fmt.Println("Usage: wetwire-aws build .")
}
`

	// .gitignore
	files[".gitignore"] = `# Build output
template.json
template.yaml
*.out

# Go
*.exe
*.exe~
*.dll
*.so
*.dylib
*.test

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
`

	// README.md - Project documentation
	files["README.md"] = fmt.Sprintf(`# %s

CloudFormation infrastructure as Go code, generated by [wetwire-aws](https://github.com/lex00/wetwire-aws-go).

## Prerequisites

- Go 1.22+
- wetwire-aws CLI

## Quick Start

`+"`"+`bash
# Build the CloudFormation template
wetwire-aws build .

# Or run directly
cd cmd && go run main.go > template.json

# Deploy with AWS CLI
aws cloudformation deploy \
  --template-file template.json \
  --stack-name %s \
  --capabilities CAPABILITY_IAM
`+"`"+`

## Project Structure

| File | Description |
|------|-------------|
| `+"`params.go`"+` | CloudFormation parameters and conditions |
| `+"`outputs.go`"+` | Stack outputs |
| `+"`security.go`"+` | IAM roles, policies, KMS keys |
| `+"`network.go`"+` | VPC, subnets, security groups, load balancers |
| `+"`compute.go`"+` | EC2 instances, Lambda functions |
| `+"`storage.go`"+` | S3 buckets, EFS |
| `+"`database.go`"+` | RDS, DynamoDB |
| `+"`main.go`"+` | Other resources |

## Modifying Resources

Resources are defined as Go struct literals:

`+"`"+`go
var MyBucket = s3.Bucket{
    BucketName: Sub{String: "${AppName}-bucket-${Environment}"},
    Tags: []any{MyBucketTagName, MyBucketTagEnv},
}
`+"`"+`

Cross-resource references use direct variable names:

`+"`"+`go
var MyPolicy = s3.BucketPolicy{
    Bucket: MyBucket,  // References the bucket above
}
`+"`"+`

## License

[Add your license here]
`, packageName, packageName)

	// CLAUDE.md - Instructions for Claude Code
	files["CLAUDE.md"] = fmt.Sprintf(`# %s Infrastructure

This package contains CloudFormation resources generated by wetwire-aws.

## Structure

- `+"`params.go`"+` - CloudFormation parameters and conditions
- `+"`outputs.go`"+` - Stack outputs
- `+"`security.go`"+` - IAM roles, policies, KMS keys
- `+"`network.go`"+` - VPC, subnets, security groups, load balancers
- `+"`compute.go`"+` - EC2 instances, Lambda functions
- `+"`storage.go`"+` - S3 buckets, EFS
- `+"`database.go`"+` - RDS, DynamoDB
- `+"`main.go`"+` - Other resources

## Usage

### Build the template
`+"`"+`bash
cd cmd && go run main.go > template.json
`+"`"+`

### Or use wetwire-aws CLI
`+"`"+`bash
wetwire-aws build .
`+"`"+`

## Modifying Resources

Each resource is defined as a Go struct. For example:

`+"`"+`go
var MyBucket = s3.Bucket{
    BucketName: "my-bucket",
}
`+"`"+`

Cross-resource references use direct variable references:

`+"`"+`go
var MyPolicy = s3.BucketPolicy{
    Bucket: MyBucket,  // Reference to another resource
}
`+"`"+`

## Intrinsic Functions

Import from `+"`github.com/lex00/wetwire-aws-go/intrinsics`"+`:

`+"`"+`go
import . "github.com/lex00/wetwire-aws-go/intrinsics"

var MyRole = iam.Role{
    RoleName: Sub{String: "${AppName}-role-${Environment}"},
}
`+"`"+`
`, packageName)

	return files
}

// GenerateCode generates Go code from a parsed IR template.
// Returns a map of filename to content.
// Files are split by category:
//   - params.go: Parameters + Conditions
//   - outputs.go: Outputs
//   - security.go: IAM, Cognito, KMS, etc.
//   - network.go: VPC, Subnets, ELB, CloudFront, etc.
//   - compute.go: EC2 Instances, Lambda, ECS, etc.
//   - storage.go: S3, EFS, etc.
//   - database.go: RDS, DynamoDB, etc.
//   - messaging.go: SNS, SQS, EventBridge, etc.
//   - monitoring.go: CloudWatch, Logs, etc.
//   - main.go: Mappings + uncategorized resources
func GenerateCode(template *IRTemplate, packageName string) map[string]string {
	ctx := newCodegenContext(template, packageName)

	// Generate multi-file output
	files := make(map[string]string)

	// First pass: categorize resources
	resourcesByCategory := make(map[string][]string)
	for _, resourceID := range ctx.resourceOrder {
		resource := ctx.template.Resources[resourceID]
		category := categorizeResourceType(resource.ResourceType)
		resourcesByCategory[category] = append(resourcesByCategory[category], resourceID)
	}

	// Second pass: generate resources by category to track parameter usage and collect imports
	categoryCode := make(map[string]string)
	categoryImports := make(map[string]map[string]bool)

	for category, resourceIDs := range resourcesByCategory {
		code, imports := generateResourcesByIDs(ctx, resourceIDs)
		categoryCode[category] = code
		categoryImports[category] = imports
	}

	// Pre-scan all expressions for parameter references before generating params
	// This ensures parameters used in conditions, resources, and Sub strings are included
	prescanAllForParams(ctx)

	// Generate params.go if there are used parameters or conditions
	paramsCode, paramsImports := generateParams(ctx)
	conditionsCode := generateConditions(ctx)
	if paramsCode != "" || conditionsCode != "" {
		combined := paramsCode
		if conditionsCode != "" {
			if combined != "" {
				combined += "\n\n"
			}
			combined += conditionsCode
		}
		files["params.go"] = buildFile(ctx.packageName, "Parameters and Conditions", paramsImports, combined)
	}

	// Generate outputs.go if there are outputs
	if outputsCode, outputsImports := generateOutputs(ctx); outputsCode != "" {
		files["outputs.go"] = buildFile(ctx.packageName, "Outputs", outputsImports, outputsCode)
	}

	// Generate category files
	categoryDescriptions := map[string]string{
		"security":   "Security resources: IAM, Cognito, KMS, etc.",
		"network":    "Network resources: VPC, Subnets, Load Balancers, CloudFront, etc.",
		"compute":    "Compute resources: EC2, Lambda, ECS, etc.",
		"storage":    "Storage resources: S3, EFS, etc.",
		"database":   "Database resources: RDS, DynamoDB, etc.",
		"messaging":  "Messaging resources: SNS, SQS, EventBridge, etc.",
		"monitoring": "Monitoring resources: CloudWatch, Logs, etc.",
		"cicd":       "CI/CD resources: CodeBuild, CodePipeline, etc.",
		"infra":      "Infrastructure resources: CloudFormation, Config, etc.",
		"main":       "Main resources",
	}

	for category, code := range categoryCode {
		if code == "" {
			continue
		}

		imports := categoryImports[category]
		description := categoryDescriptions[category]
		if description == "" {
			description = category + " resources"
		}

		// Add mappings to main file only
		if category == "main" {
			if mappingsCode := generateMappings(ctx); mappingsCode != "" {
				code = mappingsCode + "\n\n" + code
			}
		}

		// Remove intrinsics import if the code doesn't actually use any intrinsic types
		// Resource/parameter references resolve to direct variable names, not intrinsic types
		if imports["github.com/lex00/wetwire-aws-go/intrinsics"] && !codeUsesIntrinsics(code) {
			delete(imports, "github.com/lex00/wetwire-aws-go/intrinsics")
		}

		filename := category + ".go"
		files[filename] = buildFile(ctx.packageName, description, imports, code)
	}

	// If there are only mappings and no main resources, still generate main.go
	if _, hasMain := categoryCode["main"]; !hasMain {
		if mappingsCode := generateMappings(ctx); mappingsCode != "" {
			imports := make(map[string]bool)
			if codeUsesIntrinsics(mappingsCode) {
				imports["github.com/lex00/wetwire-aws-go/intrinsics"] = true
			}
			files["main.go"] = buildFile(ctx.packageName, "Mappings", imports, mappingsCode)
		}
	}

	return files
}

// codeUsesIntrinsics checks if generated code actually uses intrinsic types.
// Resource/parameter references resolve to direct variable names, not intrinsic types,
// so we need to check if any intrinsic struct types are present in the code.
func codeUsesIntrinsics(code string) bool {
	intrinsicTypes := []string{
		"Sub{", "SubWithMap{", "Ref{", "GetAtt{", "Join{", "Select{", "GetAZs{",
		"If{", "Equals{", "And{", "Or{", "Not{", "FindInMap{", "Split{", "Cidr{",
		"Condition{", "ImportValue{", "Transform{", "Json{", "Parameter{", "Output{",
		"AWS_REGION", "AWS_ACCOUNT_ID", "AWS_STACK_NAME", "AWS_STACK_ID",
		"AWS_PARTITION", "AWS_URL_SUFFIX", "AWS_NO_VALUE", "AWS_NOTIFICATION_ARNS",
		"PolicyDocument{", "PolicyStatement{", "DenyStatement{", "AllowStatement{",
		"ServicePrincipal{", "AWSPrincipal{", "FederatedPrincipal{", "Tag{",
	}
	for _, t := range intrinsicTypes {
		if strings.Contains(code, t) {
			return true
		}
	}
	return false
}

// buildFile constructs a complete Go source file.
func buildFile(packageName, description string, imports map[string]bool, code string) string {
	var sections []string

	// Package header
	header := fmt.Sprintf("// Package %s contains CloudFormation resources.\n", packageName)
	if description != "" {
		header += fmt.Sprintf("// %s\n", description)
	}
	header += "//\n// Generated by wetwire-aws import.\n"
	header += fmt.Sprintf("package %s", packageName)
	sections = append(sections, header)

	// Imports
	if len(imports) > 0 {
		var importLines []string
		sortedImports := sortedKeys(imports)
		for _, imp := range sortedImports {
			if imp == "github.com/lex00/wetwire-aws-go/intrinsics" {
				importLines = append(importLines, fmt.Sprintf("\t. %q", imp))
			} else {
				importLines = append(importLines, fmt.Sprintf("\t%q", imp))
			}
		}
		sections = append(sections, fmt.Sprintf("import (\n%s\n)", strings.Join(importLines, "\n")))
	}

	// Code
	sections = append(sections, code)

	return strings.Join(sections, "\n\n") + "\n"
}

// codegenContext holds state during code generation.
type codegenContext struct {
	template         *IRTemplate
	packageName      string
	imports          map[string]bool // import path -> true
	resourceOrder    []string        // topologically sorted resource IDs
	currentResource  string          // current resource module being generated (e.g., "ec2", "cloudfront")
	currentTypeName  string          // current resource type name (e.g., "Distribution", "VPC")
	currentProperty  string          // current property being generated (e.g., "SecurityGroupIngress")
	currentLogicalID string          // current resource's logical ID (e.g., "SecurityGroup")

	// Block-style property type declarations
	// Each property type instance becomes its own var declaration
	propertyBlocks []propertyBlock // collected during resource traversal
	blockNameCount map[string]int  // for generating unique names

	// Track which parameters are directly referenced via Ref
	usedParameters map[string]bool

	// Track unknown resource types (placeholders) - GetAtt must use explicit GetAtt{} for these
	unknownResources map[string]bool

	// Track which GetAtt references would create initialization cycles
	// Key is "sourceLogicalID:targetLogicalID", value is true if this reference is cyclic
	cyclicGetAttRefs map[string]bool
}

// propertyBlock represents a top-level var declaration for a property type instance.
type propertyBlock struct {
	varName    string         // e.g., "LoggingBucketBucketEncryption"
	typeName   string         // e.g., "s3.Bucket_BucketEncryption"
	properties map[string]any // property key-value pairs for generation
	isPointer  bool           // whether this should be a pointer type (&Type{})
	order      int            // insertion order for stable sorting
}

func newCodegenContext(template *IRTemplate, packageName string) *codegenContext {
	ctx := &codegenContext{
		template:         template,
		packageName:      packageName,
		imports:          make(map[string]bool),
		blockNameCount:   make(map[string]int),
		usedParameters:   make(map[string]bool),
		unknownResources: make(map[string]bool),
		cyclicGetAttRefs: make(map[string]bool),
	}

	// Topologically sort resources
	ctx.resourceOrder = topologicalSort(template)

	// Pre-scan for unknown resource types so GetAtt can use explicit GetAtt{} for them
	for _, res := range template.Resources {
		module, _ := resolveResourceType(res.ResourceType)
		if module == "" {
			ctx.unknownResources[res.LogicalID] = true
		}
	}

	// Pre-scan for SAM implicit resources
	// SAM auto-generates resources that aren't in the template but may be referenced
	detectSAMImplicitResources(ctx)

	// Detect initialization cycles and mark GetAtt references that need explicit form
	detectInitializationCycles(ctx)

	return ctx
}
