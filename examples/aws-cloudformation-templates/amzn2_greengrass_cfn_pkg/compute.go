// Package amzn2_greengrass_cfn_pkg contains CloudFormation resources.
// Compute resources: EC2, Lambda, ECS, etc.
//
// Generated by wetwire-aws import.
package amzn2_greengrass_cfn_pkg

import (
	"github.com/lex00/cloudformation-schema-go/enums"
	. "github.com/lex00/wetwire-aws-go/intrinsics"
	"github.com/lex00/wetwire-aws-go/resources/ec2"
	"github.com/lex00/wetwire-aws-go/resources/lambda"
)

var CreateThingFunctionCode = lambda.Function_Code{
	ZipFile: `import sys
import cfnresponse
import boto3
from botocore.exceptions import ClientError
import json
import logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

policyDocument = {
    'Version': '2012-10-17',
    'Statement': [
        {
            'Effect': 'Allow',
            'Action': 'iot:*',
            'Resource': '*'
        },
        {
            'Effect': 'Allow',
            'Action': 'greengrass:*',
            'Resource': '*'
        }
    ]
}


def handler(event, context):
    responseData = {}
    try:
        logger.info('Received event: {}'.format(json.dumps(event)))
        result = cfnresponse.FAILED
        client = boto3.client('iot')
        thingName=event['ResourceProperties']['ThingName']
        if event['RequestType'] == 'Create':
            thing = client.create_thing(
                thingName=thingName
            )
            response = client.create_keys_and_certificate(
                setAsActive=True
            )
            certId = response['certificateId']
            certArn = response['certificateArn']
            certPem = response['certificatePem']
            privateKey = response['keyPair']['PrivateKey']
            client.create_policy(
                policyName='{}-full-access'.format(thingName),
                policyDocument=json.dumps(policyDocument)
            )
            response = client.attach_policy(
                policyName='{}-full-access'.format(thingName),
                target=certArn
            )
            response = client.attach_thing_principal(
                thingName=thingName,
                principal=certArn,
            )
            logger.info('Created thing: %s, cert: %s and policy: %s' % 
                (thingName, certId, '{}-full-access'.format(thingName)))
            result = cfnresponse.SUCCESS
            responseData['certificateId'] = certId
            responseData['certificatePem'] = certPem
            responseData['privateKey'] = privateKey
            responseData['iotEndpoint'] = client.describe_endpoint(endpointType='iot:Data-ATS')['endpointAddress']
        elif event['RequestType'] == 'Update':
            logger.info('Updating thing: %s' % thingName)
            result = cfnresponse.SUCCESS
        elif event['RequestType'] == 'Delete':
            logger.info('Deleting thing: %s and cert/policy' % thingName)
            response = client.list_thing_principals(
                thingName=thingName
            )
            for i in response['principals']:
                response = client.detach_thing_principal(
                    thingName=thingName,
                    principal=i
                )
                response = client.detach_policy(
                    policyName='{}-full-access'.format(thingName),
                    target=i
                )
                response = client.update_certificate(
                    certificateId=i.split('/')[-1],
                    newStatus='INACTIVE'
                )
                response = client.delete_certificate(
                    certificateId=i.split('/')[-1],
                    forceDelete=True
                )
                response = client.delete_policy(
                    policyName='{}-full-access'.format(thingName),
                )
                response = client.delete_thing(
                    thingName=thingName
                )
            result = cfnresponse.SUCCESS
    except ClientError as e:
        logger.error('Error: {}'.format(e))
        result = cfnresponse.FAILED
    logger.info('Returning response of: {}, with result of: {}'.format(result, responseData))
    sys.stdout.flush()
    cfnresponse.send(event, context, result, responseData)
`,
}

var CreateThingFunction = lambda.Function{
	Code: CreateThingFunctionCode,
	Description: "Create thing, certificate, and policy, return cert and private key",
	Handler: "index.handler",
	Role: LambdaExecutionRole.Arn,
	Runtime: enums.LambdaRuntimePython312,
	Timeout: 60,
}

var GGSampleFunctionCode = lambda.Function_Code{
	ZipFile: `import os
from threading import Timer
import greengrasssdk


counter = 0
client = greengrasssdk.client('iot-data')


def telemetry():
    '''Publish incrementing value to telemetry topic every 2 seconds'''
    global counter
    counter += 1
    client.publish(
        topic='{}/telem'.format(os.environ['CORE_NAME']),
        payload='Example telemetry counter, value: {}'.format(counter)
    )
    Timer(5, telemetry).start()
# Call telemetry() to start telemetry publish
telemetry()


def function_handler(event, context):
    '''Echo message on /in topic to /out topic'''
    client.publish(
        topic='{}/out'.format(os.environ['CORE_NAME']),
        payload=event
    )
`,
}

var GGSampleFunction = lambda.Function{
	Code: GGSampleFunctionCode,
	Description: "Long running lambda that provides telemetry and pub/sub echo",
	FunctionName: Join{Delimiter: "_", Values: []any{
	CoreName,
	"sample",
}},
	Handler: "index.function_handler",
	Role: LambdaExecutionRole.Arn,
	Runtime: enums.LambdaRuntimePython312,
	Timeout: 60,
}

var GGSampleFunctionVersion = lambda.Version{
	FunctionName: GGSampleFunction.Arn,
}

var GroupDeploymentResetFunctionEnvironment = lambda.Function_Environment{
	Variables: Json{"STACK_NAME": AWS_STACK_NAME},
}

var GroupDeploymentResetFunctionCode = lambda.Function_Code{
	ZipFile: `"Group Deployment Reset Function"

# pylint: disable=line-too-long,logging-fstring-interpolation

import os
import sys
import json
import logging
import cfnresponse
import boto3
from botocore.exceptions import ClientError

logger = logging.getLogger()
logger.setLevel(logging.INFO)

session = boto3.session.Session()
region = os.env["AWS_REGION"]
partition = session.get_partition_for_region(region)
c = session.client("greengrass")
iam = session.client("iam")
role_name = f"greengrass_cfn_{os.environ['STACK_NAME']}_ServiceRole"


def find_group(thingName):
    "Find the group based on the name"

    response_auth = ""

    response = c.list_groups()
    for group in response["Groups"]:
        thingfound = False
        group_version = c.get_group_version(
            GroupId=group["Id"], GroupVersionId=group["LatestVersion"]
        )

        core_arn = group_version["Definition"].get("CoreDefinitionVersionArn", "")
        if core_arn:
            core_id = core_arn[
                core_arn.index("/cores/") + 7 : core_arn.index("/versions/")
            ]
            core_version_id = core_arn[
                core_arn.index("/versions/") + 10 : len(core_arn)
            ]
            thingfound = False
            response_core_version = c.get_core_definition_version(
                CoreDefinitionId=core_id, CoreDefinitionVersionId=core_version_id
            )
            if "Cores" in response_core_version["Definition"]:
                for thing_arn in response_core_version["Definition"]["Cores"]:
                    if thingName == thing_arn["ThingArn"].split("/")[1]:
                        thingfound = True
                        break
        if thingfound:
            logger.info(f"found thing: {thingName}, group id is: {group['Id']}")
            response_auth = group["Id"]
            return response_auth

    return ""


def manage_greengrass_role(cmd):
    "Greengrass role"

    if cmd == "CREATE":
        r = iam.create_role(
            RoleName=role_name,
            AssumeRolePolicyDocument='{"Version": "2012-10-17","Statement": [{"Effect": "Allow","Principal": {"Service": "greengrass.amazonaws.com"},"Action": "sts:AssumeRole"}]}',
            Description="Role for CloudFormation blog post",
        )
        role_arn = r["Role"]["Arn"]
        iam.attach_role_policy(
            RoleName=role_name,
            PolicyArn=f"arn:{partition}:iam::policy/service-role/AWSGreengrassResourceAccessRolePolicy",
        )
        c.associate_service_role_to_account(RoleArn=role_arn)
        logger.info(f"Created and associated role {role_name}")
    else:
        try:
            r = iam.get_role(RoleName=role_name)
            role_arn = r["Role"]["Arn"]
            c.disassociate_service_role_from_account()
            iam.delete_role(RoleName=role_name)
            logger.info(f"Disassociated and deleted role {role_name}")
        except ClientError:
            return


def handler(event, context):
    "Lambda handler"

    responseData = {}
    try:
        logger.info(f"Received event: {json.dumps(event)}")
        result = cfnresponse.FAILED
        thingName = event["ResourceProperties"]["ThingName"]
        if event["RequestType"] == "Create":
            try:
                c.get_service_role_for_account()
                result = cfnresponse.SUCCESS
            except ClientError:
                manage_greengrass_role("CREATE")
                logger.info("Greengrass service role created")
                result = cfnresponse.SUCCESS
        elif event["RequestType"] == "Delete":
            group_id = find_group(thingName)
            logger.info(f"Group id to delete: {group_id}")
            if group_id:
                c.reset_deployments(Force=True, GroupId=group_id)
                result = cfnresponse.SUCCESS
                logger.info("Forced reset of Greengrass deployment")
                manage_greengrass_role("DELETE")
            else:
                logger.error(f"No group Id for thing: {thingName} found")
    except ClientError as e:
        logger.error(f"Error: {e}")
        result = cfnresponse.FAILED
    logger.info(f"Returning response of: {result}, with result of: {responseData}")
    sys.stdout.flush()
    cfnresponse.send(event, context, result, responseData)`,
}

var GroupDeploymentResetFunction = lambda.Function{
	Code: GroupDeploymentResetFunctionCode,
	Description: "Resets any deployments during stack delete and manages Greengrass service role needs",
	Environment: &GroupDeploymentResetFunctionEnvironment,
	Handler: "index.handler",
	Role: LambdaExecutionRole.Arn,
	Runtime: enums.LambdaRuntimePython312,
	Timeout: 60,
}

var InstanceAZFunctionCode = lambda.Function_Code{
	ZipFile: `import sys
import cfnresponse
import boto3
from botocore.exceptions import ClientError
import json
import logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

c = boto3.client('ec2')


def handler(event, context):
    responseData = {}
    try:
        logger.info('Received event: {}'.format(json.dumps(event)))
        result = cfnresponse.FAILED
        if event['RequestType'] == 'Create':
            r = c.describe_reserved_instances_offerings(
                Filters=[
                    {
                        'Name': 'scope',
                        'Values': [
                            'Availability Zone',
                        ]
                    },
                ],
                IncludeMarketplace=False,
                InstanceType='t3.micro',
            )
            x = r['ReservedInstancesOfferings']
            while 'NextToken' in r:
                r = c.describe_reserved_instances_offerings(
                    Filters=[
                        {
                            'Name': 'scope',
                            'Values': [
                                'Availability Zone',
                            ]
                        },
                    ],
                    IncludeMarketplace=False,
                    InstanceType='t3.micro',
                    NextToken=r['NextToken']
                )
                x.extend(r['ReservedInstancesOfferings'])
            responseData['AvailabilityZone'] = set(d['AvailabilityZone'] for d in x).pop()
            result = cfnresponse.SUCCESS
        else:
            result = cfnresponse.SUCCESS
    except ClientError as e:
        logger.error('Error: {}'.format(e))
        result = cfnresponse.FAILED
    logger.info('Returning response of: %s, with result of: %s' % (result, responseData))
    sys.stdout.flush()
    cfnresponse.send(event, context, result, responseData)
`,
}

var InstanceAZFunction = lambda.Function{
	Code: InstanceAZFunctionCode,
	Description: "Queries account and region for supported AZ",
	Handler: "index.handler",
	Role: LambdaExecutionRole.Arn,
	Runtime: enums.LambdaRuntimePython312,
	Timeout: 60,
}

var GreengrassInstanceTagName = Tag{
	Key: "Name",
	Value: Join{Delimiter: "-", Values: []any{
	"Greengrass Core Blog ",
	CoreName,
}},
}

var GreengrassInstance = ec2.Instance{
	ImageId: LatestAmiId,
	InstanceType: InstanceType,
	KeyName: myKeyPair,
	SecurityGroupIds: Split{",", InstanceSecurityGroup.GroupId},
	SubnetId: SubnetAPublic,
	Tags: []any{GreengrassInstanceTagName},
	UserData: Base64{Sub{String: "#!/bin/bash\nyum -y install python3-pip\npip3 install greengrasssdk\nadduser --system ggc_user\ngroupadd --system ggc_group\n\n# https://docs.aws.amazon.com/greengrass/latest/developerguide/what-is-gg.html#gg-core-download-tab\ncurl -O https://d1onfpft10uf5o.cloudfront.net/greengrass-core/downloads/1.9.1/greengrass-linux-x86-64-1.9.1.tar.gz\ntar xf greengrass-linux-x86*.gz -C /\necho -n \"${IoTThing.certificatePem}\" > /greengrass/certs/${IoTThing.certificateId}.pem\necho -n \"${IoTThing.privateKey}\" > /greengrass/certs/${IoTThing.certificateId}.key\ncd /greengrass/config\n# Create Greengrass config file from inputs and parameters\n# Can be enhanced to manage complete installation of Greengrass and credentials\ncat <<EOT > config.json          \n{\n  \"coreThing\" : {\n    \"caPath\" : \"root.ca.pem\",\n    \"certPath\" : \"${IoTThing.certificateId}.pem\",\n    \"keyPath\" : \"${IoTThing.certificateId}.key\",\n    \"thingArn\" : \"arn:${AWS::Partition}:iot:${AWS::Region}:${AWS::AccountId}:thing/${CoreName}_Core\",\n    \"iotHost\" : \"${IoTThing.iotEndpoint}\",\n    \"ggHost\" : \"greengrass-ats.iot.${AWS::Region}.amazonaws.com\"\n  },\n  \"runtime\" : {\n    \"cgroup\" : {\n      \"useSystemd\" : \"yes\"\n    }\n  },\n  \"managedRespawn\" : false,\n  \"crypto\" : {\n    \"principals\" : {\n      \"SecretsManager\" : {\n        \"privateKeyPath\" : \"file:///greengrass/certs/${IoTThing.certificateId}.key\"\n      },\n      \"IoTCertificate\" : {\n        \"privateKeyPath\" : \"file:///greengrass/certs/${IoTThing.certificateId}.key\",\n        \"certificatePath\" : \"file:///greengrass/certs/${IoTThing.certificateId}.pem\"\n      }\n    },\n    \"caPath\" : \"file:///greengrass/certs/root.ca.pem\"\n  }\n}\nEOT\n\ncd /greengrass/certs/\ncurl -o root.ca.pem https://www.amazontrust.com/repository/AmazonRootCA1.pem\ncd /tmp\n# Create Greengrass systemd file - thanks to: https://gist.github.com/matthewberryman/fa21ca796c3a2e0dfe8224934b7b055c\ncat <<EOT > greengrass.service\n[Unit]\nDescription=greengrass daemon\nAfter=network.target\n\n[Service]\nExecStart=/greengrass/ggc/core/greengrassd start\nType=simple\nRestartSec=2\nRestart=always\nUser=root\nPIDFile=/var/run/greengrassd.pid\n\n[Install]\nWantedBy=multi-user.target\nEOT\ncp greengrass.service /etc/systemd/system\nsystemctl enable greengrass.service\nreboot\n"}},
}
